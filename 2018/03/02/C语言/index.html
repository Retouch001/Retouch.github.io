<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Retouch,iOS,技术博客,Retouch001" />










<meta name="description" content="数据和C数据类型关键字基本数据类型使用11个关键字：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。 有符号整数： 这种类型可以取正值和负值。  int：系统的基本整数类型。C保证int类型至少有16位长。 short或short int：最大的short整数不大于最大的int整数值。C保证sho">
<meta property="og:type" content="article">
<meta property="og:title" content="C">
<meta property="og:url" content="https://retouch001.github.io/2018/03/02/C语言/index.html">
<meta property="og:site_name" content="Retouch的博客">
<meta property="og:description" content="数据和C数据类型关键字基本数据类型使用11个关键字：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。 有符号整数： 这种类型可以取正值和负值。  int：系统的基本整数类型。C保证int类型至少有16位长。 short或short int：最大的short整数不大于最大的int整数值。C保证sho">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-12T06:47:36.178Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C">
<meta name="twitter:description" content="数据和C数据类型关键字基本数据类型使用11个关键字：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。 有符号整数： 这种类型可以取正值和负值。  int：系统的基本整数类型。C保证int类型至少有16位长。 short或short int：最大的short整数不大于最大的int整数值。C保证sho">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://retouch001.github.io/2018/03/02/C语言/"/>





  <title>C | Retouch的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/Retouch001" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a> 

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Retouch的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">EVERYTHING FOR TRUTH</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://retouch001.github.io/2018/03/02/C语言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Retouch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Retouch的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T17:32:36+08:00">
                2018-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-12T14:47:36+08:00">
                2018-03-12
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,545
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据和C"><a href="#数据和C" class="headerlink" title="数据和C"></a>数据和C</h1><h2 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h2><p>基本数据类型使用11个关键字：<code>int、long、short、unsigned、char、float、double、signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code>。</p>
<p><strong>有符号整数：</strong></p>
<p>这种类型可以取正值和负值。</p>
<ol>
<li>int：系统的基本整数类型。C保证int类型至少有16位长。</li>
<li>short或short int：最大的short整数不大于最大的int整数值。C保证short类型至少有16位长。</li>
</ol>
<ul>
<li>long或long int：这种类型的整数不小于最大的int整数值。C保证long至少有32位长。</li>
<li>long long或long long int：这种数据类型的整数不小于最大的long整数值。long long类型至少是64位长。</li>
</ul>
<p><strong>无符号整数：</strong></p>
<p>无符号整数只有0和正值，这使得无符号数可以表达的比有符号数更大的正值。使用unsigned关键字表示无符号数，例如：unsigned int、unsigned long和unsigned short。</p>
<p><strong>字符：</strong></p>
<p>字符包括印刷字符，如A、&amp;和+。在定义中，char类型使用1个字节的存储空间表示一个字符。出于历史原因，字符字节通常为8位，但出于表示基本字符的需要，它也可以为16位或者更长。</p>
<ol>
<li><code>char</code>： 字符类型的关键字。一些实现使用有符号的<code>cha</code>r，另外一些则使用无符号char。C允许使用<code>signed</code>和<code>unsigned</code>关键字标记char的符号属性。</li>
</ol>
<p><strong>布尔值：</strong></p>
<p>布尔值表示<code>true</code>和<code>false</code>；C使用1代表<code>true</code>，0代表<code>false</code>。</p>
<ol>
<li><code>_Bool</code>:此类型的关键字。布尔值是一个无符号整数，其存储只需要能够表示1和0的空间。</li>
</ol>
<p><strong>实浮点数：</strong></p>
<p>实浮点数可以有正值或负值。</p>
<ol>
<li><code>float</code>：系统的基本浮点类型。至少能表示6位有效数字。</li>
<li><code>double</code>：范围可能更大的浮点类型。能表示比float类型更多的有效数字(至少10位，通常会更多)以及更大的指数。</li>
</ol>
<ul>
<li><code>long double</code>：范围再大的浮点类型。</li>
</ul>
<h2 id="位、字节和字"><a href="#位、字节和字" class="headerlink" title="位、字节和字"></a>位、字节和字</h2><p>最小的存储单位称为位(bit)。它可以容纳两个值(0或1)之一。位是计算机存储的基本单位。</p>
<p>字节(byte)是常用的计算机存储单位。几乎对于所有的机器，一个字节均为8位。由于每个位或0或1，所以一个8位的字节包含256种可能的0、1组合。这些组合可用于表示0到255的整数或者一组字符。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>计算机中，浮点数和整数有很大的不同，它们的存储和运算都有很大区别。</p>
<p>计算机内存中用数值编码来表示字符。美国最常用的数值编码是ASCII码，C也支持其他编码的使用，字符常量是计算机系统所使用的数值编码的符号表示，它表示为单引号中的一个字符。</p>
<h1 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h1><p>声明一些数组的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> candy[<span class="number">365</span>];</span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>];</span><br></pre></td></tr></table></figure>
<p>方括号[]表示candy和其他两个标识符均为数组，方括号内的数字指明了数组包含的元素数目。</p>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p><code>int powers[8] = {1, 2, 4, 8, 16, 32, 64};</code></p>
<p><strong><em>有时候需要只读数组，在这种情况下，建议使用关键字const。</em></strong></p>
<p><code>const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 31, 31, 30, 31};</code></p>
<ol>
<li>当使用空的方括号对数组进行初始化时，编译器会根据列表中的数值数目来确定数组大小。</li>
<li>运算符sizeof给出其后的对象或类型的大小。因此sizeof days是整个数组的大小，sizeof days[0]是一个元素的大小。整个数组的大小除以单个元素的大小就是数组中元素的数目。</li>
</ol>
<h2 id="为数组赋值"><a href="#为数组赋值" class="headerlink" title="为数组赋值"></a>为数组赋值</h2><p>声明完数组后，可以借助数组的索引对数组成员进行赋值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter, evens[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span>(counter = <span class="number">0</span>, counter &lt; <span class="number">50</span>, counter++)&#123;</span><br><span class="line">	evens[counter] = <span class="number">2</span>*counter;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C不允许把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表形式进行赋值(初始化的时候除外)。下面这段代码展示了一些不允许的赋值方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oxen [<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>&#125;; <span class="comment">//这里是允许的,下面的都是不合法的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test[<span class="number">5</span>];</span><br><span class="line">test = oxen;</span><br><span class="line">test[<span class="number">5</span>] = oxen[<span class="number">5</span>];</span><br><span class="line">test[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组和指针的关联"><a href="#数组和指针的关联" class="headerlink" title="数组和指针的关联"></a>数组和指针的关联</h2><p>数组名也是该数组的首元素的地址。也就是说，如果flizny是一个数组，下面的代码是正确的：</p>
<p><code>flizny == &amp;flizny[0];</code>    <code>&amp;</code>是地址运算符</p>
<p>在C中，对一个指针加一的结果是对该指针增加一个存储单元。对于数组而言，地址会增加到下一个元素的地址，而不是下一个字节。这就是为什么声明一个数组时必须声明它所指向对象的类型。</p>
<ol>
<li>指针的数值就是它所指向的对象的地址。</li>
<li>在指针前运用运算符*就可以得到该指针所指向的对象的数值。</li>
</ol>
<ul>
<li>对指针加1，等价于对指针的值加上它指向的对象的字节大小。</li>
</ul>
<p>下面的等式体现了C的优点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;dates[<span class="number">2</span>];<span class="comment">//相同的地址</span></span><br><span class="line">*(date + <span class="number">2</span>) == dates[<span class="number">2</span>];<span class="comment">//相同的值</span></span><br></pre></td></tr></table></figure>
<h2 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h2><p>如果实现这样一个对一个int类型的数组求和的函数，可以使用一个指针参量来确定数组的开始点，使用一个整数参量来指明数组的元素个数。但这并不是向函数传递数组信息的唯一方法。另一种方法是传递两个指针，第一个指针指明数组的起始地址，第二个指针指明数组的结束地址。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> marbles[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span> ,<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">	<span class="keyword">long</span> answer;</span><br><span class="line">	answer = sump(marbles, marbles + <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sump</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">		total += *start;</span><br><span class="line">		start++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h2><p>下面的列表描述了可对指针变量执行的基本操作：</p>
<ul>
<li>赋值</li>
<li>求值</li>
<li>取指针地址</li>
<li>增加指针的值</li>
<li>从指针中减去一个整数</li>
<li>求差值</li>
<li>比较</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>C把数组名解释为该数组首元素的地址，也就是说，数组名和指向首元素的指针是等价的。通常，数组和指针是紧密联系的。如果ar是数组，那么表达式ar[i]和*(ar+i)是等价的。</p>
<p>C不支持把整个数组作为函数参数来传递，但是可以传递数组的地址。然后函数可以利用该地址来处理原始数组。如果函数功能不需要修改原始数组，那么在声明相应的形式参量时，需要加上关键字const。</p>
<p>对指针加上一个整数或进行增量运算时，指针值的改变都是以所指向对象的字节大小为单位的。也就是说，如果pd指向数组内的一个8字节长的double数值，则对pd加1就相当于对它的值加上数值8.这样，该指针就会指向数组的下一个元素。</p>
</blockquote>
<h1 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h1><p>在分析存储类之前，我们需要理解一些术语的意义：作用域、链接以及存储时期。</p>
<ul>
<li><strong>作用域</strong>：作用域描述了程序中可以访问一个标识符的一个或多个区域。一个C变量的作用域可以是代码块作用域、函数原型作用域和文件作用域。</li>
</ul>
<ol>
<li>代码块作用域：在代码块中定义的变量具有代码块作用域。</li>
<li>函数原型作用域：函数原型作用域从变量定义处一直到原型声明的末尾。</li>
<li>文件作用域：一个在所有函数之外定义的变量具有文件作用域。</li>
</ol>
<ul>
<li><strong>链接</strong>：C中一共有三种链接类型，外部链接、内部链接和空链接。一个C变量具有三种链接之一。<ol>
<li>空链接：具有代码块作用域或者函数原型作用域的变量属于空链接。</li>
<li>内部链接：具有代码块作用域的并且用static修饰的变量为内部链接。</li>
<li>外部链接：和内部链接一样具有代码块作用域且被关键字extern或者没有被关键字修饰（属于文件作用域的变量如没有关键字修饰C默认为extern修饰）的具有外部链接。</li>
</ol>
</li>
<li><strong>存储时期</strong>：一个C变量具有静态存储时期或自动存储时期之一。</li>
</ul>
<blockquote>
<p>C使用作用域、链接和存储时期来定义了5种存储类：自动、寄存器、具有代码块作用域的静态、具有外部链接的静态和具有内部链接的静态。</p>
</blockquote>
<ul>
<li><p><strong>自动变量</strong>：属于自动存储类的变量具有自动存储时期、代码块作用域和空链接的特点。</p>
</li>
<li><p><strong>寄存器变量</strong>：通常变量存储在内存中。如果幸运的话，寄存器变量可以被存储在CPU寄存器中（速度更快的可用内存中），从而可以比普通变量更快地访问和操作。由于寄存器变量多是存储在一个寄存器中而非内存中，所以无法获得寄存器变量的地址。自动变量与寄存器变量都有代码块作用域、空链接和自动存储时期。通常使用存储类标识符register可以声明寄存器变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> quick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们说幸运是因为声明一个寄存器类变量仅是一个请求，而非一条指令。编译器必须在您的请求和可用寄存器的个数之间权衡，所以您可能达成不了自己的愿望。这种情况下，变量成为一个普通的自动变量；然而，您依然不能对它使用地址运算符。</p>
</li>
<li><p><strong>具有代码块作用域的静态变量</strong>：<strong><em>静态是指变量的位置固定不动，不是值不可改变的意思。</em></strong>代码块作用域的静态变量具有代码块作用域、空链接和静态存储时期。</p>
</li>
<li><p><strong>具有外部链接的静态变量</strong>：外部链接的静态变量具有文件作用域、外部链接和静态存储时期。</p>
</li>
<li><p><strong>具有内部链接的静态变量</strong>：内部链接的静态变量具有文件作用域、内部链接和静态存储时期。</p>
</li>
</ul>
<p>存储类说明符：auto、register、static、extern和typedef。</p>
<ul>
<li>auto：表明一个变量具有自动存储时期。</li>
<li>register：请求变量存储在寄存器内。</li>
<li>static：表明一个变量具有静态存储时期。</li>
<li>extern：表明您在声明一个已经在别处定义了的变量。</li>
</ul>
<p>前五种存储类有一个共同的特点：在决定了哪一个存储类之后就自动决定了作用域和存储时期。您的选择服从预先制定的内存管理规则。然而还有另外一种选择给您更多灵活性。这一选择就是使用库函数来分配和管理内存。</p>
<p>这种方式主要工具是函数malloc()，它接收一个参数：所需的内存字节数。然后malloc()找到可用内存中一个大小合适的块。内存是匿名的。然而，它却可以返回那块内存的地址。因此，您可以把那个地址赋值个一个指针变量，并使用该指针来访问那块内存。函数malloc()可以用来返回数组指针、结构指针等，因此一般需要把返回的类型指派为适当的类型。但将void指针赋值给其他类型的指针并不构成冲突。如果malloc()找不到所需的空间，它将返回空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> *ptd;</span><br><span class="line">ptd = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="number">30</span>*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>
<p>一般的，对应每个<code>malloc()</code>调用，应该调用一次<code>free()</code>。函数free()的参数是先前<code>malloc()</code>返回的地址，它释放先前分配的内存。</p>
<p>这种方式被称为动态内存分配，动态分配的内存在调用<code>malloc()</code>或<code>calloc()</code>时产生，在调用free()时释放。由程序员而不是一系列固定的规则控制内存持续时间，因此内存块可以在一个函数中创建，而在另一个函数中释放。由于这点，动态内存分配所有的内存部分可能变成碎片状，也就是说，在活动的内存块之间散布着未使用的字节片。不管怎样，使用动态内存往往导致进程比使用堆栈内存慢。</p>
<h1 id="结构和其他数据形式"><a href="#结构和其他数据形式" class="headerlink" title="结构和其他数据形式"></a>结构和其他数据形式</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>声明一个结构体，首先使用关键字<code>struct</code>，它表示接下来是一个结构。后面是一个可选的标记，它是用来引用该结构的快速标记。声明就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct book library, panshin, *ptbook;</span><br></pre></td></tr></table></figure>
<p>结构变量library和panshin均包含title、author和value部分。指针ptbook可以指向library、panshin，或任何其他book结构变量。</p>
<p><code>struct book library</code>是以下声明的简化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">&#125;libary<span class="comment">/*在定义之后跟变量名*/</span></span><br></pre></td></tr></table></figure>
<p>换句话说声明结构的过程和定义结构变量的过程可以被合并成一步。</p>
<p>初始化一个结构可以使用与初始化数组相似的语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"world"</span>,</span><br><span class="line">    <span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如要访问一个结构的成员用结构成员运算符点<code>.</code>就可以。例如<code>library.value</code>。</p>
<p>声明一个结构数组和声明其他任何类型的数组一样。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[10];</span></span><br></pre></td></tr></table></figure>
<p>这条语句声明一个library为一个具有10个元素的数组，数组的每个元素都是book类型的结构。因此，library[0]是一个book结构。</p>
<ul>
<li>指向结构的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> first[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> last[<span class="number">20</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span></span><br><span class="line">    <span class="keyword">char</span> favfood[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> job[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] = &#123;</span></span><br><span class="line">	&#123;&#123;<span class="string">"Ewen"</span>,<span class="string">"Villard"</span>&#125;,</span><br><span class="line">	<span class="string">"grilled salmon"</span>,</span><br><span class="line">	<span class="string">"personality coach"</span>,</span><br><span class="line">	<span class="number">67.00</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;&#123;<span class="string">"Ewen"</span>,<span class="string">"Villard"</span>&#125;,</span><br><span class="line">	<span class="string">"hello"</span>,</span><br><span class="line">	<span class="string">"world"</span>,</span><br><span class="line">	<span class="number">68.00</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> *<span class="title">him</span>;</span><span class="comment">/*这是一个指向结构的指针*/</span></span><br><span class="line">    him = &amp;fellow[<span class="number">0</span>];<span class="comment">/*告诉该指针它要指向的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若要使用结构指针访问结构成员，可以有两种方式：</p>
<ul>
<li><p>使用一个新运算符：-&gt;。下面的例子可以清楚的表达这个意思：</p>
<p><code>him -&gt;income is fellow[0].income  if him == &amp;fellow[0]</code></p>
</li>
<li><p>如果<code>him = &amp;fellow[0]</code>，那么<code>*him = fellow[0]</code>，因为&amp;和 * 是一对互逆的运算符。因此可以做以下替代：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fellow[<span class="number">0</span>].income == (*him).income;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类型</p>
</li>
</ul>
<p>可以使用枚举类型声明代表整数常量的符号名称。通过使用关键字<code>enum</code>，可以创建一个新类型并指定它可以具有的值。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;</span><br><span class="line">    red,</span><br><span class="line">    orange,</span><br><span class="line">    yellow,</span><br><span class="line">    green,</span><br><span class="line">    blue,</span><br><span class="line">    violet</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br></pre></td></tr></table></figure>
<p>第一个声明设置spectrum为标记名，从而允许您把enum spectrum作为一个类型名使用。第二个声明使得color成为该类型的一个变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span>(color == yellow)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The color is yellow"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><em>typedef</em></strong>简介</p>
<p><code>typedef</code>工具是一种高级数据特性，它是您能够为某一类型创建您自己的名字。在这个方面，它和<code>#define</code>相似，但是它们具有三个不同之处：</p>
<ol>
<li>与<code>#define</code>不同，<code>typedef</code>给出的符号名称仅限于类型，而不对值。</li>
<li><code>typedef</code>的解释由编译器，而不是预处理器执行。</li>
<li>虽然它的范围有限，但在其受限范围内，<code>typedef比#define</code>更灵活。</li>
</ol>
<p>举个简单的typedef的例子，假如要对1字节的数值使用术语BYTE，您只须像定义一个char变量来定义BYTE，然后在这个定义前面加上关键字typedef，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure>
<p>随后就可以使用BYTE来定义变量了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BYTE x, y[<span class="number">10</span>], *z;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数指针</p>
</li>
</ul>
<p>声明指向函数的指针是可以的。典型的用法是，一个函数指针可以作为另一个函数的参数，告诉第二个函数使用哪个函数。 函数也有地址，这是因为函数的机器语言实现是由载入到内存中的代码组成。指向函数的指针中保存着函数代码起始处的地址。</p>
<p>当声明一个函数指针时，必须声明它指向的函数类型。要指定函数类型，就要指出函数的返回类型以及函数的参量类型。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span> <span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要声明指向上述函数的指针，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pt) (<span class="keyword">char</span> *);<span class="comment">//pt是一个指向函数的指针</span></span><br></pre></td></tr></table></figure>
<p>下面举个简单的例子来阐述函数指针的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span> <span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span> <span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pt) (<span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mis[] = <span class="string">"Hello world"</span>;</span><br><span class="line">    pf = ToUpper;</span><br><span class="line">    (*pf)(mis);<span class="comment">//把ToUpper作用于mis(语法1)</span></span><br><span class="line">    pf = ToLower;</span><br><span class="line">    pf(mis);<span class="comment">//把ToLower作用于mis(语法2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>历史上，贝尔实验室的C和UNIX的开发者采用第一种观点，而Berkeley的UNIX的扩展者采用第二种观点。为了保持与现有代码的兼容性，ANSIC把这二者作为等价形式全部接受。</p>
<h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><blockquote>
<p>通常向硬件设备发送一两个字节来控制该设备，其中每一位都有特定的含义。同样的，通常使用代表特定项目的特定位来存储操作系统关于文件的信息。许多压缩和加密操作都对单独的位进行操作。高级语言一般不处理这一级别的细节；C在提供高级语言便利的同时，也能够在典型的为汇编语言所保留的级别上工作，这是其成为编写设备驱动程序和嵌入式代码的首选语言。</p>
</blockquote>
<h2 id="二进制、位和字节"><a href="#二进制、位和字节" class="headerlink" title="二进制、位和字节"></a>二进制、位和字节</h2><p>一个十进制的数<code>2157</code>，我们可以写成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2*1000 + 1*100 + 5*10 + 7*1</span><br><span class="line">2*10^3 + 1*10^2 + 5*10^1 + 7*10^0</span><br></pre></td></tr></table></figure>
<p>计算机的位只有两种选择0或1(关闭或打开)，因此，以2为基数的系统适用于计算机。它用2的幂代替10的幂。以2为基数表示的数字成为二进制数。例如，二进制1101可以表示为以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*2^3 + 1*2^2 + 0*2^1 + 1*2^0</span><br></pre></td></tr></table></figure>
<p>以十进制表示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*8 + 1*4 + 0*2 + 1*1 = 13</span><br></pre></td></tr></table></figure>
<p>一个字节通常有八位，128是2的7次幂，以此类推。该字节可以保存的最大数据是把所有的位都设置为1：<code>1111 1111</code>，该二进制数的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128  + 64 + 32 + 16 +8 + 4 + 2 + 1 = 255</span><br></pre></td></tr></table></figure>
<h2 id="其他基数"><a href="#其他基数" class="headerlink" title="其他基数"></a>其他基数</h2><blockquote>
<p>计算机世界通常使用基于八和十六的数制系统。因为8和16都是2的幂，所以这些系统比十进制系统更接近于计算机的二进制系统。</p>
</blockquote>
<p>十六进制指以16为基数的进制系统。该系统使用16的幂，使用的数字是0到15。10到15用A到F来表示。例如，十六进制数A3F代表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10*16^2 + 3*16^1 + 15*16^0 = 2623(以十位基数)</span><br></pre></td></tr></table></figure>
<p><strong>每个十六进制位对应于一个4位的二进制数，因此两个十六进制位恰好对应于一个8位字节。第一个十六进制位位表示高4位，第二个表示低4位。这使得十六进制适用于表示字节。</strong>下表显示了这个对应关系：</p>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>十六进制数</th>
<th>二进制数</th>
<th>十进制数</th>
<th>十六进制数</th>
<th>二进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>10</td>
<td>A</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>11</td>
<td>B</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>12</td>
<td>C</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>13</td>
<td>D</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>14</td>
<td>E</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>15</td>
<td>F</td>
<td>1111</td>
</tr>
</tbody>
</table>
<h2 id="C的运算符"><a href="#C的运算符" class="headerlink" title="C的运算符"></a>C的运算符</h2><p>C提供位的逻辑运算符和位移运算符。4个位运算符用于整型数据，包括char。将这些运算符称为位运算符的原因是它们对每位进行操作，而不影响左右两侧的位。</p>
<h3 id="二进制反码或按位取反："><a href="#二进制反码或按位取反：" class="headerlink" title="二进制反码或按位取反：~"></a>二进制反码或按位取反：~</h3><p>一元运算符~将每个1变为0，将每个0变为1，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~(1001 1010)</span><br><span class="line"> (01100101)</span><br></pre></td></tr></table></figure>
<h3 id="位与-AND-：-amp"><a href="#位与-AND-：-amp" class="headerlink" title="位与(AND)：&amp;"></a>位与(AND)：&amp;</h3><p>二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应为都为1时结果才为1。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1001 0011)&amp;(0011 1101)</span><br><span class="line">(00010001)</span><br></pre></td></tr></table></figure>
<p>C也有一个组合的位与赋值运算符：<code>&amp;=</code>。下面两个语句产生相同的结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= <span class="number">0377</span>;</span><br><span class="line">val = val &amp; <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>
<h3 id="位或-OR-："><a href="#位或-OR-：" class="headerlink" title="位或(OR)：|"></a>位或(OR)：|</h3><p>二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1001 0011) | (0011 1101)</span><br><span class="line">(1011 1111)</span><br></pre></td></tr></table></figure>
<h3 id="位异或："><a href="#位异或：" class="headerlink" title="位异或：^"></a>位异或：^</h3><p>二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对于位有一个位1(但是不都为1)，那么结果为1。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1001 0011) ^ (0011 1101)</span><br><span class="line">(1010 1110)</span><br></pre></td></tr></table></figure>
<h3 id="用法：掩码"><a href="#用法：掩码" class="headerlink" title="用法：掩码"></a>用法：掩码</h3><p><code>位与</code>运算符通常跟掩码一起使用。掩码是某些位设为开而某些位设置为关的位组合。掩码中的零覆盖了另一个数中相应的位，所以该过程称为<code>使用掩码</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &amp;= 0xff;</span><br></pre></td></tr></table></figure>
<p>值0xff的二进制形式为11111111，十进制形式为0377。该掩码留下ch的最后8位，将其余位设为0。无论最初的ch是8位、16位或是更多，都将最终的值修整到一个字节中。</p>
<h3 id="用法：打开关闭位"><a href="#用法：打开关闭位" class="headerlink" title="用法：打开关闭位"></a>用法：打开关闭位</h3><p>打开一个值中特定的位，同时保持其他位不变。可以使用<code>位或</code>运算符来实现。例如：</p>
<p>考虑MASK，其位1设为1。下面的语句将flags中的位1设为1，并保留其他位不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags |= MASK;</span><br></pre></td></tr></table></figure>
<p>若想关闭flags中的位1，可以使用如下表达：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags &amp;= ~MASK;</span><br></pre></td></tr></table></figure>
<h3 id="用法：转置位"><a href="#用法：转置位" class="headerlink" title="用法：转置位"></a>用法：转置位</h3><p>转置一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开该位。您可以使用位异或运算符来转置一个位。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags ^= MASK;</span><br></pre></td></tr></table></figure>
<h3 id="用法：查看一位的值"><a href="#用法：查看一位的值" class="headerlink" title="用法：查看一位的值"></a>用法：查看一位的值</h3><p>如果你想查看flags的位1是否为1，不应该简单的比较flags与MASK。即使flags中的位1被设为1，flags中的其他位也会使比较结果为非真。必须屏蔽flags中其他位，以便只把flags中的位1和MASK相比较：</p>
<p><code>if((flags &amp; MASK) == MASK)</code></p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符用&lt;&lt; 、&gt;&gt;表示左移和右移。左移运算符将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出的位用0填充。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1000 1010) &lt;&lt; 2		</span><br><span class="line">(0010 1000)</span><br></pre></td></tr></table></figure>
<p>位移运算符能欧提供快捷、高效的对2的幂的乘法和除法。</p>
<table>
<thead>
<tr>
<th>number &lt;&lt; n</th>
<th>number乘以2的n次幂</th>
</tr>
</thead>
<tbody>
<tr>
<td>number &gt;&gt; n</td>
<td>如果number为非负，number除以2的n次幂</td>
</tr>
</tbody>
</table>
<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><p>对位进行操作的第二种方法是使用位字段。位字段由一个结构申明建立，该结构申明为每个字段提供标签，并决定字段宽度。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	unsingned <span class="keyword">int</span> autfd:<span class="number">1</span>;</span><br><span class="line">	unsingned <span class="keyword">int</span> bldfc:<span class="number">1</span>;</span><br><span class="line">	unsingned <span class="keyword">int</span> undln:<span class="number">1</span>;</span><br><span class="line">	unsingned <span class="keyword">int</span> itals:<span class="number">1</span>; </span><br><span class="line">&#125;prnt;</span><br></pre></td></tr></table></figure>
<p>该定义使prnt包含四个一位字段。现在，可以使用普通的结构成员运算符将值赋值给单独的字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prnt.itals = <span class="number">0</span>;		</span><br><span class="line">prnt.undln = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>使C区别于许多高级语言的特性之一是访问整数中个别位的能力。该特性通常是程序与硬件设备和操作系统相连接的关键。</strong></p>
<p><strong>C有两个主要访问位的工具。一个是位运算符，另一个是在结构中创建位字段的能力。</strong></p>
<p><strong>典型地，使用这些特性的程序仅限于特定的硬件平台或操作系统，并且被设计为不可移植的。</strong></p>
<h1 id="C预处理器和C库"><a href="#C预处理器和C库" class="headerlink" title="C预处理器和C库"></a>C预处理器和C库</h1><blockquote>
<p>C预处理器和C库是C语言的两个重要的附件。执行预处理指令的C预处理器可以在编译源代码前对源代码进行调整。C库提供了许多有助于完成各种任务的函数，这些任务包括：输入、输出、文件处理、内存管理、排序与搜索、数学计算、字符串处理等等。</p>
</blockquote>
<h2 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h2><ul>
<li>明显常量</li>
</ul>
<p>预处理器指令从#开始，到其后第一个换行符为止。也就是说，指令的长度限于一行代码。在预处理开始前，系统会删除反斜线和换行符的组合。因此可以把指令扩展到几个物理行，由这些物理行组成单个逻辑行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OW <span class="meta-string">"Sometimes you just have to follow \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">your soul"</span></span></span><br></pre></td></tr></table></figure>
<p>每个#define行由三部分组成。第一部分为指令#define自身。第二部分为所选择的缩略语，这些缩略语称为宏。第三部分称为替换列表或主体。预处理器在程序中发现了宏的实例后，总会用实体代替该宏。</p>
<ul>
<li>在#define中使用参数</li>
</ul>
<p>在#define中使用参数，可以创建外形和作用都与函数相似的类函数宏。类函数宏的定义中，用圆括号括起一个或多个参数，随后这些参数出现在替换部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br></pre></td></tr></table></figure>
<p>函数调用与宏调用之间有着许多重要的差异，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">SQUARE(x+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>得到的结果出乎你的意料，结果为8。这是因为预处理器不进行计算，而只进行字符串的替换。替换后的表达式为<code>x+2*x+2</code>。</p>
<p>解决这种问题的方法是只需在定义时使用足够多的圆括号，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SQUARE(X) (X)*(X)</span><br></pre></td></tr></table></figure>
<p><strong>从中得到的经验是使用必须的足够多的圆括号来保证以正确的顺序进行运算和结合。</strong></p>
<ul>
<li>利用宏参数创建字符串：#运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR (X) pintf(<span class="meta-string">"The square of X is %d"</span>,X);</span></span><br><span class="line"></span><br><span class="line">PSQR(<span class="number">8</span>);</span><br><span class="line">输出结果为</span><br><span class="line">The square of X is <span class="number">64.</span></span><br></pre></td></tr></table></figure>
<p>注意，引号中的字符串中的X被看作普通文本，而不是被看作一个可被替换的语言符号。C具有如下特点：如果X是一个宏参量，那么#X可以把参数名转化为相应的字符串。该过程称为字符串化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define PSQR (X) pintf(&quot;The square of #X is %d&quot;,X);</span><br><span class="line"></span><br><span class="line">PSQR(8);</span><br><span class="line">//输出结果为</span><br><span class="line">The square of 8 is 64.</span><br></pre></td></tr></table></figure>
<ul>
<li>预处理的粘合剂：##运算符</li>
</ul>
<p>和#运算符一样，##运算符可以用于类函数宏的替换部分。另外，##还可以用于类对象宏的替换部分。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define XNAME(n) x##n</span><br><span class="line"></span><br><span class="line">XNAME(4);</span><br><span class="line">//输出结果为</span><br><span class="line">x4;</span><br></pre></td></tr></table></figure>
<ul>
<li>可变宏：<code>...和_ _VA_ARGS_ _</code></li>
</ul>
<p>有些函数（如printf()）接收可变数量的参数。实现思想就是宏定义中参数列表的最后一个参数为省略号。这样，预定义宏<code>_ _VA_ARGS_ _</code>就可以被用在替换部分中，以表明省略号代表什么。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(X,...) printf(<span class="meta-string">"Message"</span> #X <span class="meta-string">":"</span> _ _VA_ARGS_ _)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    PR(<span class="number">1</span>,<span class="string">"x = %g\n"</span>,x);</span><br><span class="line">    PR(<span class="number">2</span>,<span class="string">"x = %.2f, y = %.4f\n"</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果为</span></span><br><span class="line">Message <span class="number">1</span>: x = <span class="number">48</span>;</span><br><span class="line">Message <span class="number">2</span>: x = <span class="number">48.00</span> y = <span class="number">6.9286</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>宏还是函数</li>
</ul>
<blockquote>
<p>宏于函数的选择实际上是时间与空间的权衡。宏产生内联代码；也就是说，在程序中产生语句。如果使用宏20次，则会把20行代码插入程序中。如果使用函数20次，那么程序中只有一份函数语句的拷贝，因此节省了空间。另一方面，程序的控制必须转移到函数中并随后返回调试程序，因此这比内联代码花费的时间更长。</p>
</blockquote>
<ul>
<li><p>其他指令</p>
<ol>
<li><p><code>#undef</code>指令：<code>#undef</code>指令取消定义一个给定的#define。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LIMIT 400 </span><br><span class="line">#undef LIMIT</span><br></pre></td></tr></table></figure>
<p>现在就可以重新定义LIMIT，以使它有一个新的值。即使开始没有定义LIMIT，取消LIMIT的定义也是合法的。</p>
</li>
<li><p><code>#ifdef、#else和#endif</code>   <code>#ifndef</code>指令：使用这些指令告诉编译器根据编译时的条件接收或忽略信息块。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef MAVIS</span><br><span class="line"># include &quot;hurse.h&quot;</span><br><span class="line"># define STABLES 5</span><br><span class="line">#else</span><br><span class="line"># include &quot;cow.h&quot;</span><br><span class="line"># define STABLES 15</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>类似于<code>#ifdef</code>指令，<code>#ifndef</code>指令可以与<code>#else</code>、#endif指令一起使用。<code>#ifndef</code>判断后面的标识符是否为未定义的，#ifndef的反义词为<code>#ifdef</code>。#ifndef通常用来定义此前未定义的常量。</p>
</li>
<li><p><code>#if和#elif</code>指令：#if指令更像常规的C中的if；#if后跟常量整数表达式。如果表达式为非零值，则表达式为真。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYS == 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ibmpc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 2</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vax.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 3</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mac.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"general.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数</p>
<p>通常函数调用需要一定的时间开销。这意味着执行调用时花费了时间用于建立调用、传递参数、跳转到函数代码段并返回。使用类函数宏的一个原因就是可以减少执行时间。C99还提供另一种方法：内联函数，“把函数变为内联函数将建议编译器尽可能快速地调用该函数。上述建议的效果由实现来定义”。因此，使函数变为内联函数可能会简化函数的调用机制，但也可能不起作用。</p>
<p>创建内联函数的方法是在函数声明中使用函数说明符inline。通常首次使用内联函数前在文件中对该函数进行定义。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">eatline</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    eatline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联函数应该比较短小。对于很长的函数，调用函数的时间少于执行函数主体的时间；此时，使用内联函数不会节省多少时间。</p>
</li>
</ol>
</li>
</ul>
<h2 id="C库"><a href="#C库" class="headerlink" title="C库"></a>C库</h2><p>最初并没有官方的C库，后来，基于UNIX的C实现变成了事实上的标准。于是ANSIC委员会主要以这个标准为基础开发了一个官方标准库。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p>数学库包含许多有用的数学函数。头文件math.h提供这些函数声明或原型。</p>
<h2 id="通用工具库"><a href="#通用工具库" class="headerlink" title="通用工具库"></a>通用工具库</h2><p>通用工具库包含各种函数，其中包括随机数产生函数、搜索和排序函数、转换函数和内存管理函数。这些函数的原型在头文件stdlib.h中。</p>
<h2 id="诊断库"><a href="#诊断库" class="headerlink" title="诊断库"></a>诊断库</h2><p>由头文件assert.h支持的诊断库是设计用于辅助调试程序的小型库。它又宏assert()构成。</p>
<h1 id="高级数据表示"><a href="#高级数据表示" class="headerlink" title="高级数据表示"></a>高级数据表示</h1><h2 id="数组与链表"><a href="#数组与链表" class="headerlink" title="数组与链表"></a>数组与链表</h2><p>结构本身不能含有同类型的结构，但是它可以含有指向同类型结构的指针。这样的定义是定义一个链表的基础。链表是一个列表，其中的每一项都包含描述何处能找到下一项的信息。下面给出一段链表的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSIZE 45</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">film</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[TSIZE];</span><br><span class="line">    <span class="keyword">int</span> rating;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">film</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">film</span> *<span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">film</span> *<span class="title">prev</span> = <span class="title">NULL</span>, *<span class="title">current</span>;</span></span><br><span class="line">    <span class="keyword">char</span> input[TSIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Enter first movie title"</span>);</span><br><span class="line">    <span class="keyword">while</span> (gets(input) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        current = (struct film *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct film));</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev-&gt;next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(current-&gt;title, input);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Enter your rating &lt;0-10&gt;:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;current-&gt;rating);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Enter next movie title "</span>);</span><br><span class="line">        prev = current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No data entered"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Here is the moive list:\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    current = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Movie: %s--------Rating: %d\n"</span>,current-&gt;title,current-&gt;rating);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye!\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多编程问题，比如创建一个列表或队列，可以用链表(一种动态分配的结构序列链)或数组来处理。每种形式都有其优势和缺点，下表总结了链表和数组的性质：</p>
<table>
<thead>
<tr>
<th>数据形式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>C对其直接支持，提供随机访问</td>
<td>编译时决定其大小；插入和删除元素很费时</td>
</tr>
<tr>
<td>链表</td>
<td>运行时决定其大小快速插入和删除元素</td>
<td>不能随机访问用户；必须提供编程支持</td>
</tr>
</tbody>
</table>
<p>向数组中插入一个元素，必须移动其他元素以便安插新元素，新元素离数组头越近，要移动的元素越多。而向链表插入一个节点，只需分配两个指针值。类似的，从数组中删除一个要重新安置大量元素，而从链表中删除一个节点只需重新设置一个指针并释放被删除节点使用的内存。</p>
<p>其次，考虑如何访问列表中的成员，对数组来说，可用数组索引直接访问任意元素。这被称为随机访问。对链表来说，必须从列表头开始，逐个节点的移动到所需的节点处，这叫做顺序访问。数组也可以顺序访问。</p>
<p>选择何种数据类型是取决于具体问题的。如果列表需要频繁地插入和删除元素因而不断地调整大小，并且不需要经常搜索，链表是更好的选择。而如果列表基本稳定只是偶尔插入或删除一些元素，但却经常搜索，则数组是更好的选择。</p>
<p>如果需要一种既支持频繁地插入和删除又支持频繁搜索的数据类型，链表和数组都不是针对这个目标的理想选择。另一种形式，二叉搜索树。我们会在下文详细介绍。</p>
<h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a>抽象数据类型(ADT)</h2><p>计算机科学已经研究出一种定义新类型的成功方法。这种方法使用三个步骤来完成从抽象到具体的过程：</p>
<ol>
<li>为类型的属性和可对类型执行的操作提供一个抽象的描述。这个描述不应受任何特定实现的约束，甚至不应受到任何特定编程语言的约束。这样一种正式的抽象描述被称为抽象数据类型(ADT)；</li>
<li>开发一个实现该ADT的编程接口。即说明如何存储数据并描述用于执行所需操作的函数集合。比如在C中，可能同时提供一个结构的定义和用来操作该结构的函数原型。这些函数对用户自定义类型的作用和C内置运算符对C基本类型的作用相同。想要使用这种新类型的人可以使用这个接口来进行编程。</li>
<li>编写代码来实现这个接口。当然，这一步至关重要，但是使用这种新类型的程序员无须了解实现的细节。</li>
</ol>
<h2 id="队列-ADT"><a href="#队列-ADT" class="headerlink" title="队列(ADT)"></a>队列(ADT)</h2><p>队列是具有两个特殊属性的列表。第一，新的项目只能被添加到列表结尾处。第二，项目只能从列表开始处被移出。可以将队列看成是一队买电影票的人。您在队尾加入队列，在买完票后从队首离开。队列是一种“先进先出(FIFO)”的数据形式。</p>
<p>下面我们将队列的代码实现用ADT来表现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> queue_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> queue_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> gumption;</span><br><span class="line">    <span class="keyword">int</span> charisma;</span><br><span class="line">&#125;Item;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQUEUE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    Item item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line">    <span class="keyword">int</span> items;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeQueue</span><span class="params">(Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueItemCount</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(Item item, Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(Item *pitem, Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyTheQueue</span><span class="params">(Queue *pq)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* queue_h */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyToNode</span><span class="params">(Item item, Node *pn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyToItem</span><span class="params">(Node *pn, Item *pi)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeQueue</span><span class="params">(Queue *pq)</span></span>&#123;</span><br><span class="line">    pq-&gt;front = pq-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    pq-&gt;items = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pq-&gt;items == MAXQUEUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pq-&gt;items == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueItemCount</span><span class="params">(<span class="keyword">const</span> Queue *pq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pq-&gt;items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(Item item, Queue *pq)</span></span>&#123;</span><br><span class="line">    Node *pnew;</span><br><span class="line">    <span class="keyword">if</span> (QueueIsFull(pq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pnew = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unable to allocate memory!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CopyToNode(item, pnew);</span><br><span class="line">    pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (QueueIsEmpty(pq)) &#123;</span><br><span class="line">        pq-&gt;front = pnew;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pq-&gt;rear-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">    pq-&gt;rear = pnew;</span><br><span class="line">    pq-&gt;items++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(Item *pitem, Queue *pq)</span></span>&#123;</span><br><span class="line">    Node *pt;</span><br><span class="line">    <span class="keyword">if</span> (QueueIsEmpty(pq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CopyToItem(pq-&gt;front, pitem);</span><br><span class="line">    pt = pq-&gt;front;</span><br><span class="line">    pq-&gt;front = pq-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(pt);</span><br><span class="line">    pq-&gt;items--;</span><br><span class="line">    <span class="keyword">if</span> (pq-&gt;items == <span class="number">0</span>) &#123;</span><br><span class="line">        pq-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyQueue</span><span class="params">(Queue *pq)</span></span>&#123;</span><br><span class="line">    Item dummy;</span><br><span class="line">    <span class="keyword">while</span> (!QueueIsEmpty(pq)) &#123;</span><br><span class="line">        DeQueue(&amp;dummy, pq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyToNode</span><span class="params">(Item item, Node *pn)</span></span>&#123;</span><br><span class="line">    pn-&gt;item = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyToItem</span><span class="params">(Node *pn, Item *pi)</span></span>&#123;</span><br><span class="line">    *pi = pn-&gt;item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是一种结合了折半搜索策略的链接结构。树中的每一个节点都包含一个项目和两个指向其他节点的指针。这种构思是每一个节点都有两个子节点，左节点和右节点。在左节点中的项目是父节点中项目的前序项，而在右节点中的项目是父节点中项目的后序项。这种关系存在于每一个有子节点的节点中。</p>
<p>二叉树ADT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tree_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tree_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> petname[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> petkind[<span class="number">20</span>];</span><br><span class="line">&#125;Item;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXITEMS 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    Item item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeTree</span><span class="params">(Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeIsEmpty</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeIsFull</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeItemCount</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddItem</span><span class="params">(<span class="keyword">const</span> Item *pi, Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InTree</span><span class="params">(<span class="keyword">const</span> Item *pi, <span class="keyword">const</span> Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteItem</span><span class="params">(<span class="keyword">const</span> Item *pi, Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line">void Traverse(const Tree *ptree, void (*pfun)(Item item));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">(Tree *ptree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* tree_h */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    Node *parent;</span><br><span class="line">    Node *child;</span><br><span class="line">&#125;Pair;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">MakeNode</span><span class="params">(<span class="keyword">const</span> Item *pi)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(<span class="keyword">const</span> Item *i1, <span class="keyword">const</span> Item *i2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ToRight</span><span class="params">(<span class="keyword">const</span> Item *i1, <span class="keyword">const</span> Item *i2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(Node *new_node, Node *root)</span></span>;</span><br><span class="line">static void InOrder(const Node *root, void (*pfun)(Item item));</span><br><span class="line"><span class="function"><span class="keyword">static</span> Pair <span class="title">SeekItem</span><span class="params">(<span class="keyword">const</span> Item *pi, <span class="keyword">const</span> Tree *ptree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(Node **ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteAllNodes</span><span class="params">(Node *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeTree</span><span class="params">(Tree *ptree)</span></span>&#123;</span><br><span class="line">    ptree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    ptree-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeIsEmpty</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TreeIsFull</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptree-&gt;size == MAXITEMS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeItemCount</span><span class="params">(<span class="keyword">const</span> Tree *ptree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptree-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AddItem</span><span class="params">(<span class="keyword">const</span> Item *pi, Tree *ptree)</span></span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    <span class="keyword">if</span> (TreeIsFull(ptree)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Tree is full\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SeekItem(pi, ptree).child != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Attemped to add duplicate item\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node = MakeNode(pi);</span><br><span class="line">    <span class="keyword">if</span> (new_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn`t create node\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptree-&gt;size++;</span><br><span class="line">    <span class="keyword">if</span> (ptree-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ptree-&gt;root = new_node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        AddNode(new_node, ptree-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InTree</span><span class="params">(<span class="keyword">const</span> Item *pi, <span class="keyword">const</span> Tree *ptree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (SeekItem(pi, ptree).child == <span class="literal">NULL</span>)?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteItem</span><span class="params">(<span class="keyword">const</span> Item *pi, Tree *ptree)</span></span>&#123;</span><br><span class="line">    Pair look;</span><br><span class="line">    look = SeekItem(pi, ptree);</span><br><span class="line">    <span class="keyword">if</span> (look.child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (look.parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DeleteNode(&amp;ptree-&gt;root);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (look.parent-&gt;left == look.child)&#123;</span><br><span class="line">        DeleteNode(&amp;look.parent-&gt;left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        DeleteNode(&amp;look.parent-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    ptree-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Traverse(const Tree *ptree, void (*pfun)(Item item))&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(ptree-&gt;root, pfun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">(Tree *ptree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DeleteAllNodes(ptree-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    ptree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    ptree-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void InOrder(const Node *root, void (*pfun)(Item item))&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(root-&gt;left, pfun);</span><br><span class="line">        (*pfun)(root-&gt;item);</span><br><span class="line">        InOrder(root-&gt;right, pfun);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteAllNodes</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    Node *pright;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pright = root-&gt;right;</span><br><span class="line">        DeleteAllNodes(root-&gt;left);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">        DeleteAllNodes(pright);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNode</span><span class="params">(Node *new_node, Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ToLeft(&amp;new_node-&gt;item, &amp;root-&gt;item)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;left = new_node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            AddNode(new_node, root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ToRight(&amp;new_node-&gt;item, &amp;root-&gt;item))&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;right = new_node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            AddNode(new_node, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"location error in AddNode()\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ToLeft</span><span class="params">(<span class="keyword">const</span> Item *i1, <span class="keyword">const</span> Item *i2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> comp1;</span><br><span class="line">    <span class="keyword">if</span> ((comp1 = <span class="built_in">strcmp</span>(i1-&gt;petname, i2-&gt;petname)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (comp1 == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(i1-&gt;petkind, i2-&gt;petkind) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ToRight</span><span class="params">(<span class="keyword">const</span> Item *i1, <span class="keyword">const</span> Item *i2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> comp1;</span><br><span class="line">    <span class="keyword">if</span> ((comp1 = <span class="built_in">strcmp</span>(i1-&gt;petname, i2-&gt;petname)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (comp1 == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(i1-&gt;petkind, i2-&gt;petkind) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node *<span class="title">MakeNode</span><span class="params">(<span class="keyword">const</span> Item *pi)</span></span>&#123;</span><br><span class="line">    Node *new_node;</span><br><span class="line">    new_node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (new_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        new_node-&gt;item = *pi;</span><br><span class="line">        new_node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        new_node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Pair <span class="title">SeekItem</span><span class="params">(<span class="keyword">const</span> Item *pi, <span class="keyword">const</span> Tree *ptree)</span></span>&#123;</span><br><span class="line">    Pair look;</span><br><span class="line">    look.parent = <span class="literal">NULL</span>;</span><br><span class="line">    look.child = ptree-&gt;root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (look.child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> look;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (look.child != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ToLeft(pi, &amp;(look.child-&gt;item))) &#123;</span><br><span class="line">            look.parent = look.child;</span><br><span class="line">            look.child = look.child-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ToRight(pi, &amp;(look.child-&gt;item)))&#123;</span><br><span class="line">            look.parent = look.child;</span><br><span class="line">            look.child = look.child-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> look;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(Node **ptr)</span></span>&#123;</span><br><span class="line">    Node *temp;</span><br><span class="line">    <span class="built_in">puts</span>((*ptr) -&gt;item.petname);</span><br><span class="line">    <span class="keyword">if</span> ((*ptr)-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = *ptr;</span><br><span class="line">        *ptr = (*ptr)-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((*ptr)-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = *ptr;</span><br><span class="line">        *ptr = (*ptr)-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (temp = (*ptr)-&gt;left; temp-&gt;right != <span class="literal">NULL</span>; temp = temp-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;right = (*ptr)-&gt;right;</span><br><span class="line">        temp = *ptr;</span><br><span class="line">        *ptr = (*ptr)-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/02/Git的基本用法和扩展/" rel="next" title="Git的基本用法和扩展">
                <i class="fa fa-chevron-left"></i> Git的基本用法和扩展
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Retouch" />
            
              <p class="site-author-name" itemprop="name">Retouch</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Retouch001" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:790330366@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://knightsj.github.io" title="J_Knight个人博客" target="_blank">J_Knight个人博客</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据和C"><span class="nav-number">1.</span> <span class="nav-text">数据和C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型关键字"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位、字节和字"><span class="nav-number">1.2.</span> <span class="nav-text">位、字节和字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组和指针"><span class="nav-number">2.</span> <span class="nav-text">数组和指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的初始化"><span class="nav-number">2.1.</span> <span class="nav-text">数组的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为数组赋值"><span class="nav-number">2.2.</span> <span class="nav-text">为数组赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和指针的关联"><span class="nav-number">2.3.</span> <span class="nav-text">数组和指针的关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数、数组和指针"><span class="nav-number">2.4.</span> <span class="nav-text">函数、数组和指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针操作"><span class="nav-number">2.5.</span> <span class="nav-text">指针操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">2.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储类"><span class="nav-number">3.</span> <span class="nav-text">存储类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构和其他数据形式"><span class="nav-number">4.</span> <span class="nav-text">结构和其他数据形式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">4.1.</span> <span class="nav-text">结构体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#位操作"><span class="nav-number">5.</span> <span class="nav-text">位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制、位和字节"><span class="nav-number">5.1.</span> <span class="nav-text">二进制、位和字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他基数"><span class="nav-number">5.2.</span> <span class="nav-text">其他基数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C的运算符"><span class="nav-number">5.3.</span> <span class="nav-text">C的运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制反码或按位取反："><span class="nav-number">5.3.1.</span> <span class="nav-text">二进制反码或按位取反：~</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位与-AND-：-amp"><span class="nav-number">5.3.2.</span> <span class="nav-text">位与(AND)：&amp;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位或-OR-："><span class="nav-number">5.3.3.</span> <span class="nav-text">位或(OR)：|</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位异或："><span class="nav-number">5.3.4.</span> <span class="nav-text">位异或：^</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法：掩码"><span class="nav-number">5.3.5.</span> <span class="nav-text">用法：掩码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法：打开关闭位"><span class="nav-number">5.3.6.</span> <span class="nav-text">用法：打开关闭位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法：转置位"><span class="nav-number">5.3.7.</span> <span class="nav-text">用法：转置位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用法：查看一位的值"><span class="nav-number">5.3.8.</span> <span class="nav-text">用法：查看一位的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移位运算符"><span class="nav-number">5.3.9.</span> <span class="nav-text">移位运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位字段"><span class="nav-number">5.4.</span> <span class="nav-text">位字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C预处理器和C库"><span class="nav-number">6.</span> <span class="nav-text">C预处理器和C库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C预处理器"><span class="nav-number">6.1.</span> <span class="nav-text">C预处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C库"><span class="nav-number">6.2.</span> <span class="nav-text">C库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学库"><span class="nav-number">6.3.</span> <span class="nav-text">数学库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用工具库"><span class="nav-number">6.4.</span> <span class="nav-text">通用工具库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#诊断库"><span class="nav-number">6.5.</span> <span class="nav-text">诊断库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级数据表示"><span class="nav-number">7.</span> <span class="nav-text">高级数据表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组与链表"><span class="nav-number">7.1.</span> <span class="nav-text">数组与链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象数据类型-ADT"><span class="nav-number">7.2.</span> <span class="nav-text">抽象数据类型(ADT)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列-ADT"><span class="nav-number">7.3.</span> <span class="nav-text">队列(ADT)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">7.4.</span> <span class="nav-text">二叉搜索树</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Retouch</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">18.0k</span>
  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
