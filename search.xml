<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F03%2F02%2FC%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[数据和C数据类型关键字基本数据类型使用11个关键字：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。 有符号整数： 这种类型可以取正值和负值。 int：系统的基本整数类型。C保证int类型至少有16位长。 short或short int：最大的short整数不大于最大的int整数值。C保证short类型至少有16位长。 long或long int：这种类型的整数不小于最大的int整数值。C保证long至少有32位长。 long long或long long int：这种数据类型的整数不小于最大的long整数值。long long类型至少是64位长。 无符号整数： 无符号整数只有0和正值，这使得无符号数可以表达的比有符号数更大的正值。使用unsigned关键字表示无符号数，例如：unsigned int、unsigned long和unsigned short。 字符： 字符包括印刷字符，如A、&amp;和+。在定义中，char类型使用1个字节的存储空间表示一个字符。出于历史原因，字符字节通常为8位，但出于表示基本字符的需要，它也可以为16位或者更长。 char： 字符类型的关键字。一些实现使用有符号的char，另外一些则使用无符号char。C允许使用signed和unsigned关键字标记char的符号属性。 布尔值： 布尔值表示true和false；C使用1代表true，0代表false。 _Bool:此类型的关键字。布尔值是一个无符号整数，其存储只需要能够表示1和0的空间。 实浮点数： 实浮点数可以有正值或负值。 float：系统的基本浮点类型。至少能表示6位有效数字。 double：范围可能更大的浮点类型。能表示比float类型更多的有效数字(至少10位，通常会更多)以及更大的指数。 long double：范围再大的浮点类型。 位、字节和字最小的存储单位称为位(bit)。它可以容纳两个值(0或1)之一。位是计算机存储的基本单位。 字节(byte)是常用的计算机存储单位。几乎对于所有的机器，一个字节均为8位。由于每个位或0或1，所以一个8位的字节包含256种可能的0、1组合。这些组合可用于表示0到255的整数或者一组字符。 小结计算机中，浮点数和整数有很大的不同，它们的存储和运算都有很大区别。 计算机内存中用数值编码来表示字符。美国最常用的数值编码是ASCII码，C也支持其他编码的使用，字符常量是计算机系统所使用的数值编码的符号表示，它表示为单引号中的一个字符。 数组和指针声明一些数组的例子： 123float candy[365];char code[12];int states[50]; 方括号[]表示candy和其他两个标识符均为数组，方括号内的数字指明了数组包含的元素数目。 数组的初始化int powers[8] = {1, 2, 4, 8, 16, 32, 64}; 有时候需要只读数组，在这种情况下，建议使用关键字const。 const int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 31, 31, 30, 31}; 当使用空的方括号对数组进行初始化时，编译器会根据列表中的数值数目来确定数组大小。 运算符sizeof给出其后的对象或类型的大小。因此sizeof days是整个数组的大小，sizeof days[0]是一个元素的大小。整个数组的大小除以单个元素的大小就是数组中元素的数目。 为数组赋值声明完数组后，可以借助数组的索引对数组成员进行赋值。例如： 1234int counter, evens[50];for(counter = 0, counter &lt; 50, counter++)&#123; evens[counter] = 2*counter; &#125; C不允许把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表形式进行赋值(初始化的时候除外)。下面这段代码展示了一些不允许的赋值方式： 123456int oxen [5] = &#123;5, 3, 2, 8&#125;; //这里是允许的,下面的都是不合法的int test[5];test = oxen;test[5] = oxen[5];test[5] = &#123;5, 3, 2, 8&#125;; 数组和指针的关联数组名也是该数组的首元素的地址。也就是说，如果flizny是一个数组，下面的代码是正确的： flizny == &amp;flizny[0]; &amp;是地址运算符 在C中，对一个指针加一的结果是对该指针增加一个存储单元。对于数组而言，地址会增加到下一个元素的地址，而不是下一个字节。这就是为什么声明一个数组时必须声明它所指向对象的类型。 指针的数值就是它所指向的对象的地址。 在指针前运用运算符*就可以得到该指针所指向的对象的数值。 对指针加1，等价于对指针的值加上它指向的对象的字节大小。 下面的等式体现了C的优点： 12dates + 2 == &amp;dates[2];//相同的地址*(date + 2) == dates[2];//相同的值 函数、数组和指针如果实现这样一个对一个int类型的数组求和的函数，可以使用一个指针参量来确定数组的开始点，使用一个整数参量来指明数组的元素个数。但这并不是向函数传递数组信息的唯一方法。另一种方法是传递两个指针，第一个指针指明数组的起始地址，第二个指针指明数组的结束地址。如下： 12345678910111213141516int sump(int *start, int *end);int main(void)&#123; int marbles[5] = &#123;10, 20 ,30, 40, 50&#125;; long answer; answer = sump(marbles, marbles + 5); return 0;&#125;int sump(int *start, int *end)&#123; int total = 0; while(start &lt; end)&#123; total += *start; start++; &#125;&#125; 指针操作下面的列表描述了可对指针变量执行的基本操作： 赋值 求值 取指针地址 增加指针的值 从指针中减去一个整数 求差值 比较 小结 C把数组名解释为该数组首元素的地址，也就是说，数组名和指向首元素的指针是等价的。通常，数组和指针是紧密联系的。如果ar是数组，那么表达式ar[i]和*(ar+i)是等价的。 C不支持把整个数组作为函数参数来传递，但是可以传递数组的地址。然后函数可以利用该地址来处理原始数组。如果函数功能不需要修改原始数组，那么在声明相应的形式参量时，需要加上关键字const。 对指针加上一个整数或进行增量运算时，指针值的改变都是以所指向对象的字节大小为单位的。也就是说，如果pd指向数组内的一个8字节长的double数值，则对pd加1就相当于对它的值加上数值8.这样，该指针就会指向数组的下一个元素。 存储类在分析存储类之前，我们需要理解一些术语的意义：作用域、链接以及存储时期。 作用域：作用域描述了程序中可以访问一个标识符的一个或多个区域。一个C变量的作用域可以是代码块作用域、函数原型作用域和文件作用域。 代码块作用域：在代码块中定义的变量具有代码块作用域。 函数原型作用域：函数原型作用域从变量定义处一直到原型声明的末尾。 文件作用域：一个在所有函数之外定义的变量具有文件作用域。 链接：C中一共有三种链接类型，外部链接、内部链接和空链接。一个C变量具有三种链接之一。 空链接：具有代码块作用域或者函数原型作用域的变量属于空链接。 内部链接：具有代码块作用域的并且用static修饰的变量为内部链接。 外部链接：和内部链接一样具有代码块作用域且被关键字extern或者没有被关键字修饰（属于文件作用域的变量如没有关键字修饰C默认为extern修饰）的具有外部链接。 存储时期：一个C变量具有静态存储时期或自动存储时期之一。 C使用作用域、链接和存储时期来定义了5种存储类：自动、寄存器、具有代码块作用域的静态、具有外部链接的静态和具有内部链接的静态。 自动变量：属于自动存储类的变量具有自动存储时期、代码块作用域和空链接的特点。 寄存器变量：通常变量存储在内存中。如果幸运的话，寄存器变量可以被存储在CPU寄存器中（速度更快的可用内存中），从而可以比普通变量更快地访问和操作。由于寄存器变量多是存储在一个寄存器中而非内存中，所以无法获得寄存器变量的地址。自动变量与寄存器变量都有代码块作用域、空链接和自动存储时期。通常使用存储类标识符register可以声明寄存器变量： 123int main(void)&#123; register int quick;&#125; 我们说幸运是因为声明一个寄存器类变量仅是一个请求，而非一条指令。编译器必须在您的请求和可用寄存器的个数之间权衡，所以您可能达成不了自己的愿望。这种情况下，变量成为一个普通的自动变量；然而，您依然不能对它使用地址运算符。 具有代码块作用域的静态变量：静态是指变量的位置固定不动，不是值不可改变的意思。代码块作用域的静态变量具有代码块作用域、空链接和静态存储时期。 具有外部链接的静态变量：外部链接的静态变量具有文件作用域、外部链接和静态存储时期。 具有内部链接的静态变量：内部链接的静态变量具有文件作用域、内部链接和静态存储时期。 存储类说明符：auto、register、static、extern和typedef。 auto：表明一个变量具有自动存储时期。 register：请求变量存储在寄存器内。 static：表明一个变量具有静态存储时期。 extern：表明您在声明一个已经在别处定义了的变量。 前五种存储类有一个共同的特点：在决定了哪一个存储类之后就自动决定了作用域和存储时期。您的选择服从预先制定的内存管理规则。然而还有另外一种选择给您更多灵活性。这一选择就是使用库函数来分配和管理内存。 这种方式主要工具是函数malloc()，它接收一个参数：所需的内存字节数。然后malloc()找到可用内存中一个大小合适的块。内存是匿名的。然而，它却可以返回那块内存的地址。因此，您可以把那个地址赋值个一个指针变量，并使用该指针来访问那块内存。函数malloc()可以用来返回数组指针、结构指针等，因此一般需要把返回的类型指派为适当的类型。但将void指针赋值给其他类型的指针并不构成冲突。如果malloc()找不到所需的空间，它将返回空指针。 12double *ptd;ptd = (double *)malloc(30*sizeof(double)); 一般的，对应每个malloc()调用，应该调用一次free()。函数free()的参数是先前malloc()返回的地址，它释放先前分配的内存。 这种方式被称为动态内存分配，动态分配的内存在调用malloc()或calloc()时产生，在调用free()时释放。由程序员而不是一系列固定的规则控制内存持续时间，因此内存块可以在一个函数中创建，而在另一个函数中释放。由于这点，动态内存分配所有的内存部分可能变成碎片状，也就是说，在活动的内存块之间散布着未使用的字节片。不管怎样，使用动态内存往往导致进程比使用堆栈内存慢。 结构和其他数据形式结构体声明一个结构体，首先使用关键字struct，它表示接下来是一个结构。后面是一个可选的标记，它是用来引用该结构的快速标记。声明就像下面这样： 12345struct book&#123; char title[10]; char author[10]; float value;&#125; 1struct book library, panshin, *ptbook; 结构变量library和panshin均包含title、author和value部分。指针ptbook可以指向library、panshin，或任何其他book结构变量。 struct book library是以下声明的简化： 12345struct book&#123; char title[10]; char author[10]; float value;&#125;libary/*在定义之后跟变量名*/ 换句话说声明结构的过程和定义结构变量的过程可以被合并成一步。 初始化一个结构可以使用与初始化数组相似的语法： 12345struct book library = &#123; "hello", "world", 1.95&#125;; 如要访问一个结构的成员用结构成员运算符点.就可以。例如library.value。 声明一个结构数组和声明其他任何类型的数组一样。例如： 1struct book library[10]; 这条语句声明一个library为一个具有10个元素的数组，数组的每个元素都是book类型的结构。因此，library[0]是一个book结构。 指向结构的指针 1234567891011121314151617181920212223242526272829struct names&#123; char first[20]; char last[20]&#125;;struct guy&#123; struct names handle; char favfood[20]; char job[20]; float income;&#125;;int main(void)&#123; struct guy fellow[2] = &#123; &#123;&#123;"Ewen","Villard"&#125;, "grilled salmon", "personality coach", 67.00 &#125;, &#123;&#123;"Ewen","Villard"&#125;, "hello", "world", 68.00 &#125; &#125;; struct guy *him;/*这是一个指向结构的指针*/ him = &amp;fellow[0];/*告诉该指针它要指向的地址*/&#125; 若要使用结构指针访问结构成员，可以有两种方式： 使用一个新运算符：-&gt;。下面的例子可以清楚的表达这个意思： him -&gt;income is fellow[0].income if him == &amp;fellow[0] 如果him = &amp;fellow[0]，那么*him = fellow[0]，因为&amp;和 * 是一对互逆的运算符。因此可以做以下替代： 1fellow[0].income == (*him).income; 枚举类型 可以使用枚举类型声明代表整数常量的符号名称。通过使用关键字enum，可以创建一个新类型并指定它可以具有的值。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如： 123456789enum spectrum &#123; red, orange, yellow, green, blue, violet&#125;;enum spectrum color; 第一个声明设置spectrum为标记名，从而允许您把enum spectrum作为一个类型名使用。第二个声明使得color成为该类型的一个变量。 12345int c;color = blue;if(color == yellow)&#123; printf("The color is yellow");&#125; typedef简介 typedef工具是一种高级数据特性，它是您能够为某一类型创建您自己的名字。在这个方面，它和#define相似，但是它们具有三个不同之处： 与#define不同，typedef给出的符号名称仅限于类型，而不对值。 typedef的解释由编译器，而不是预处理器执行。 虽然它的范围有限，但在其受限范围内，typedef比#define更灵活。 举个简单的typedef的例子，假如要对1字节的数值使用术语BYTE，您只须像定义一个char变量来定义BYTE，然后在这个定义前面加上关键字typedef，如： 1typedef unsigned char BYTE; 随后就可以使用BYTE来定义变量了： 1BYTE x, y[10], *z; 函数指针 声明指向函数的指针是可以的。典型的用法是，一个函数指针可以作为另一个函数的参数，告诉第二个函数使用哪个函数。 函数也有地址，这是因为函数的机器语言实现是由载入到内存中的代码组成。指向函数的指针中保存着函数代码起始处的地址。 当声明一个函数指针时，必须声明它指向的函数类型。要指定函数类型，就要指出函数的返回类型以及函数的参量类型。例如： 1void ToUpper (char *); 要声明指向上述函数的指针，可以这样做： 1void (*pt) (char *);//pt是一个指向函数的指针 下面举个简单的例子来阐述函数指针的用法： 1234567891011void ToUpper (char *);void ToLower (char *);void (*pt) (char *);int main(void)&#123; char mis[] = "Hello world"; pf = ToUpper; (*pf)(mis);//把ToUpper作用于mis(语法1) pf = ToLower; pf(mis);//把ToLower作用于mis(语法2)&#125; 历史上，贝尔实验室的C和UNIX的开发者采用第一种观点，而Berkeley的UNIX的扩展者采用第二种观点。为了保持与现有代码的兼容性，ANSIC把这二者作为等价形式全部接受。 位操作 通常向硬件设备发送一两个字节来控制该设备，其中每一位都有特定的含义。同样的，通常使用代表特定项目的特定位来存储操作系统关于文件的信息。许多压缩和加密操作都对单独的位进行操作。高级语言一般不处理这一级别的细节；C在提供高级语言便利的同时，也能够在典型的为汇编语言所保留的级别上工作，这是其成为编写设备驱动程序和嵌入式代码的首选语言。 二进制、位和字节一个十进制的数2157，我们可以写成如下形式： 122*1000 + 1*100 + 5*10 + 7*12*10^3 + 1*10^2 + 5*10^1 + 7*10^0 计算机的位只有两种选择0或1(关闭或打开)，因此，以2为基数的系统适用于计算机。它用2的幂代替10的幂。以2为基数表示的数字成为二进制数。例如，二进制1101可以表示为以下形式： 11*2^3 + 1*2^2 + 0*2^1 + 1*2^0 以十进制表示为 11*8 + 1*4 + 0*2 + 1*1 = 13 一个字节通常有八位，128是2的7次幂，以此类推。该字节可以保存的最大数据是把所有的位都设置为1：1111 1111，该二进制数的值如下： 1128 + 64 + 32 + 16 +8 + 4 + 2 + 1 = 255 其他基数 计算机世界通常使用基于八和十六的数制系统。因为8和16都是2的幂，所以这些系统比十进制系统更接近于计算机的二进制系统。 十六进制指以16为基数的进制系统。该系统使用16的幂，使用的数字是0到15。10到15用A到F来表示。例如，十六进制数A3F代表： 110*16^2 + 3*16^1 + 15*16^0 = 2623(以十位基数) 每个十六进制位对应于一个4位的二进制数，因此两个十六进制位恰好对应于一个8位字节。第一个十六进制位位表示高4位，第二个表示低4位。这使得十六进制适用于表示字节。下表显示了这个对应关系： 十进制数 十六进制数 二进制数 十进制数 十六进制数 二进制数 0 0 0000 8 8 1000 1 1 0001 9 9 1001 2 2 0010 10 A 1010 3 3 0011 11 B 1011 4 4 0100 12 C 1100 5 5 0101 13 D 1101 6 6 0110 14 E 1110 7 7 0111 15 F 1111 C的运算符C提供位的逻辑运算符和位移运算符。4个位运算符用于整型数据，包括char。将这些运算符称为位运算符的原因是它们对每位进行操作，而不影响左右两侧的位。 二进制反码或按位取反：~一元运算符~将每个1变为0，将每个0变为1，如下所示： 12~(1001 1010) (01100101) 位与(AND)：&amp;二进制运算符&amp;通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应为都为1时结果才为1。如下： 12(1001 0011)&amp;(0011 1101)(00010001) C也有一个组合的位与赋值运算符：&amp;=。下面两个语句产生相同的结果： 12val &amp;= 0377;val = val &amp; 0377; 位或(OR)：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1。如下所示： 12(1001 0011) | (0011 1101)(1011 1111) 位异或：^二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对于位有一个位1(但是不都为1)，那么结果为1。如下所示： 12(1001 0011) ^ (0011 1101)(1010 1110) 用法：掩码位与运算符通常跟掩码一起使用。掩码是某些位设为开而某些位设置为关的位组合。掩码中的零覆盖了另一个数中相应的位，所以该过程称为使用掩码，例如： 1ch &amp;= 0xff; 值0xff的二进制形式为11111111，十进制形式为0377。该掩码留下ch的最后8位，将其余位设为0。无论最初的ch是8位、16位或是更多，都将最终的值修整到一个字节中。 用法：打开关闭位打开一个值中特定的位，同时保持其他位不变。可以使用位或运算符来实现。例如： 考虑MASK，其位1设为1。下面的语句将flags中的位1设为1，并保留其他位不变： 1flags |= MASK; 若想关闭flags中的位1，可以使用如下表达： 1flags &amp;= ~MASK; 用法：转置位转置一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开该位。您可以使用位异或运算符来转置一个位。例如： 1flags ^= MASK; 用法：查看一位的值如果你想查看flags的位1是否为1，不应该简单的比较flags与MASK。即使flags中的位1被设为1，flags中的其他位也会使比较结果为非真。必须屏蔽flags中其他位，以便只把flags中的位1和MASK相比较： if((flags &amp; MASK) == MASK) 移位运算符移位运算符用&lt;&lt; 、&gt;&gt;表示左移和右移。左移运算符将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出的位用0填充。例如： 12(1000 1010) &lt;&lt; 2 (0010 1000) 位移运算符能欧提供快捷、高效的对2的幂的乘法和除法。 number &lt;&lt; n number乘以2的n次幂 number &gt;&gt; n 如果number为非负，number除以2的n次幂 位字段对位进行操作的第二种方法是使用位字段。位字段由一个结构申明建立，该结构申明为每个字段提供标签，并决定字段宽度。例如： 123456struct&#123; unsingned int autfd:1; unsingned int bldfc:1; unsingned int undln:1; unsingned int itals:1; &#125;prnt; 该定义使prnt包含四个一位字段。现在，可以使用普通的结构成员运算符将值赋值给单独的字段： 12prnt.itals = 0; prnt.undln = 1; 总结使C区别于许多高级语言的特性之一是访问整数中个别位的能力。该特性通常是程序与硬件设备和操作系统相连接的关键。 C有两个主要访问位的工具。一个是位运算符，另一个是在结构中创建位字段的能力。 典型地，使用这些特性的程序仅限于特定的硬件平台或操作系统，并且被设计为不可移植的。 C预处理器和C库 C预处理器和C库是C语言的两个重要的附件。执行预处理指令的C预处理器可以在编译源代码前对源代码进行调整。C库提供了许多有助于完成各种任务的函数，这些任务包括：输入、输出、文件处理、内存管理、排序与搜索、数学计算、字符串处理等等。 C预处理器 明显常量 预处理器指令从#开始，到其后第一个换行符为止。也就是说，指令的长度限于一行代码。在预处理开始前，系统会删除反斜线和换行符的组合。因此可以把指令扩展到几个物理行，由这些物理行组成单个逻辑行。 12#define OW "Sometimes you just have to follow \your soul" 每个#define行由三部分组成。第一部分为指令#define自身。第二部分为所选择的缩略语，这些缩略语称为宏。第三部分称为替换列表或主体。预处理器在程序中发现了宏的实例后，总会用实体代替该宏。 在#define中使用参数 在#define中使用参数，可以创建外形和作用都与函数相似的类函数宏。类函数宏的定义中，用圆括号括起一个或多个参数，随后这些参数出现在替换部分。 1#define SQUARE(X) X*X 函数调用与宏调用之间有着许多重要的差异，如下： 12int x = 2;SQUARE(x+2) 得到的结果出乎你的意料，结果为8。这是因为预处理器不进行计算，而只进行字符串的替换。替换后的表达式为x+2*x+2。 解决这种问题的方法是只需在定义时使用足够多的圆括号，如下： 1#define SQUARE(X) (X)*(X) 从中得到的经验是使用必须的足够多的圆括号来保证以正确的顺序进行运算和结合。 利用宏参数创建字符串：#运算符 12345#define PSQR (X) pintf("The square of X is %d",X);PSQR(8);输出结果为The square of X is 64. 注意，引号中的字符串中的X被看作普通文本，而不是被看作一个可被替换的语言符号。C具有如下特点：如果X是一个宏参量，那么#X可以把参数名转化为相应的字符串。该过程称为字符串化。 12345#define PSQR (X) pintf(&quot;The square of #X is %d&quot;,X);PSQR(8);//输出结果为The square of 8 is 64. 预处理的粘合剂：##运算符 和#运算符一样，##运算符可以用于类函数宏的替换部分。另外，##还可以用于类对象宏的替换部分。例如： 12345#define XNAME(n) x##nXNAME(4);//输出结果为x4; 可变宏：...和_ _VA_ARGS_ _ 有些函数（如printf()）接收可变数量的参数。实现思想就是宏定义中参数列表的最后一个参数为省略号。这样，预定义宏_ _VA_ARGS_ _就可以被用在替换部分中，以表明省略号代表什么。例如： 123456789101112#define PR(X,...) printf("Message" #X ":" _ _VA_ARGS_ _)int main(void)&#123; double x = 48; double y; y = sqrt(x); PR(1,"x = %g\n",x); PR(2,"x = %.2f, y = %.4f\n", x, y); return 0;&#125;//结果为Message 1: x = 48;Message 2: x = 48.00 y = 6.9286; 宏还是函数 宏于函数的选择实际上是时间与空间的权衡。宏产生内联代码；也就是说，在程序中产生语句。如果使用宏20次，则会把20行代码插入程序中。如果使用函数20次，那么程序中只有一份函数语句的拷贝，因此节省了空间。另一方面，程序的控制必须转移到函数中并随后返回调试程序，因此这比内联代码花费的时间更长。 其他指令 #undef指令：#undef指令取消定义一个给定的#define。例如： 12#define LIMIT 400 #undef LIMIT 现在就可以重新定义LIMIT，以使它有一个新的值。即使开始没有定义LIMIT，取消LIMIT的定义也是合法的。 #ifdef、#else和#endif #ifndef指令：使用这些指令告诉编译器根据编译时的条件接收或忽略信息块。例如： 1234567#ifdef MAVIS# include &quot;hurse.h&quot;# define STABLES 5#else# include &quot;cow.h&quot;# define STABLES 15#endif 类似于#ifdef指令，#ifndef指令可以与#else、#endif指令一起使用。#ifndef判断后面的标识符是否为未定义的，#ifndef的反义词为#ifdef。#ifndef通常用来定义此前未定义的常量。 #if和#elif指令：#if指令更像常规的C中的if；#if后跟常量整数表达式。如果表达式为非零值，则表达式为真。例如： 123456789#if SYS == 1 #include "ibmpc.h"#elif SYS == 2 #include "vax.h"#elif SYS == 3 #include "mac.h"#else #include "general.h"#endif 内联函数 通常函数调用需要一定的时间开销。这意味着执行调用时花费了时间用于建立调用、传递参数、跳转到函数代码段并返回。使用类函数宏的一个原因就是可以减少执行时间。C99还提供另一种方法：内联函数，“把函数变为内联函数将建议编译器尽可能快速地调用该函数。上述建议的效果由实现来定义”。因此，使函数变为内联函数可能会简化函数的调用机制，但也可能不起作用。 创建内联函数的方法是在函数声明中使用函数说明符inline。通常首次使用内联函数前在文件中对该函数进行定义。例如： 123456789#include &lt;stdio.h&gt;inline void eatline()&#123; while (getchar() != '\n') continue;&#125;int main()&#123; eatline();&#125; 内联函数应该比较短小。对于很长的函数，调用函数的时间少于执行函数主体的时间；此时，使用内联函数不会节省多少时间。 C库最初并没有官方的C库，后来，基于UNIX的C实现变成了事实上的标准。于是ANSIC委员会主要以这个标准为基础开发了一个官方标准库。 数学库数学库包含许多有用的数学函数。头文件math.h提供这些函数声明或原型。 通用工具库通用工具库包含各种函数，其中包括随机数产生函数、搜索和排序函数、转换函数和内存管理函数。这些函数的原型在头文件stdlib.h中。 诊断库由头文件assert.h支持的诊断库是设计用于辅助调试程序的小型库。它又宏assert()构成。 高级数据表示数组与链表结构本身不能含有同类型的结构，但是它可以含有指向同类型结构的指针。这样的定义是定义一个链表的基础。链表是一个列表，其中的每一项都包含描述何处能找到下一项的信息。下面给出一段链表的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define TSIZE 45struct film&#123; char title[TSIZE]; int rating; struct film *next;&#125;;int main (void)&#123; struct film *head = NULL; struct film *prev = NULL, *current; char input[TSIZE]; puts("Enter first movie title"); while (gets(input) != NULL &amp;&amp; input[0] != '\0') &#123; current = (struct film *)malloc(sizeof(struct film)); if (head == NULL) &#123; head = current; &#125;else&#123; prev-&gt;next = current; &#125; current-&gt;next = NULL; strcpy(current-&gt;title, input); puts("Enter your rating &lt;0-10&gt;:"); scanf("%d",&amp;current-&gt;rating); while (getchar() != '\n') &#123; continue; &#125; puts("Enter next movie title "); prev = current; &#125; if (head == NULL) &#123; printf("No data entered"); &#125;else&#123; printf("Here is the moive list:\n"); &#125; current = head; while (current != NULL) &#123; printf("Movie: %s--------Rating: %d\n",current-&gt;title,current-&gt;rating); current = current-&gt;next; &#125; current = head; while (current != NULL) &#123; free(current); current = current-&gt;next; &#125; printf("Bye!\n"); return 0;&#125; 很多编程问题，比如创建一个列表或队列，可以用链表(一种动态分配的结构序列链)或数组来处理。每种形式都有其优势和缺点，下表总结了链表和数组的性质： 数据形式 优点 缺点 数组 C对其直接支持，提供随机访问 编译时决定其大小；插入和删除元素很费时 链表 运行时决定其大小快速插入和删除元素 不能随机访问用户；必须提供编程支持 向数组中插入一个元素，必须移动其他元素以便安插新元素，新元素离数组头越近，要移动的元素越多。而向链表插入一个节点，只需分配两个指针值。类似的，从数组中删除一个要重新安置大量元素，而从链表中删除一个节点只需重新设置一个指针并释放被删除节点使用的内存。 其次，考虑如何访问列表中的成员，对数组来说，可用数组索引直接访问任意元素。这被称为随机访问。对链表来说，必须从列表头开始，逐个节点的移动到所需的节点处，这叫做顺序访问。数组也可以顺序访问。 选择何种数据类型是取决于具体问题的。如果列表需要频繁地插入和删除元素因而不断地调整大小，并且不需要经常搜索，链表是更好的选择。而如果列表基本稳定只是偶尔插入或删除一些元素，但却经常搜索，则数组是更好的选择。 如果需要一种既支持频繁地插入和删除又支持频繁搜索的数据类型，链表和数组都不是针对这个目标的理想选择。另一种形式，二叉搜索树。我们会在下文详细介绍。 抽象数据类型(ADT)计算机科学已经研究出一种定义新类型的成功方法。这种方法使用三个步骤来完成从抽象到具体的过程： 为类型的属性和可对类型执行的操作提供一个抽象的描述。这个描述不应受任何特定实现的约束，甚至不应受到任何特定编程语言的约束。这样一种正式的抽象描述被称为抽象数据类型(ADT)； 开发一个实现该ADT的编程接口。即说明如何存储数据并描述用于执行所需操作的函数集合。比如在C中，可能同时提供一个结构的定义和用来操作该结构的函数原型。这些函数对用户自定义类型的作用和C内置运算符对C基本类型的作用相同。想要使用这种新类型的人可以使用这个接口来进行编程。 编写代码来实现这个接口。当然，这一步至关重要，但是使用这种新类型的程序员无须了解实现的细节。 队列(ADT)队列是具有两个特殊属性的列表。第一，新的项目只能被添加到列表结尾处。第二，项目只能从列表开始处被移出。可以将队列看成是一队买电影票的人。您在队尾加入队列，在买完票后从队首离开。队列是一种“先进先出(FIFO)”的数据形式。 下面我们将队列的代码实现用ADT来表现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#ifndef queue_h#define queue_h#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct item&#123; int gumption; int charisma;&#125;Item;#define MAXQUEUE 10typedef struct node&#123; Item item; struct node *next;&#125;Node;typedef struct queue&#123; Node *front; Node *rear; int items;&#125;Queue;void InitializeQueue(Queue *pq);bool QueueIsFull(const Queue *pq);bool QueueIsEmpty(const Queue *pq);int QueueItemCount(const Queue *pq);bool EnQueue(Item item, Queue *pq);bool DeQueue(Item *pitem, Queue *pq);void EmptyTheQueue(Queue *pq);#endif /* queue_h */#include "queue.h"#include &lt;stdlib.h&gt;static void CopyToNode(Item item, Node *pn);static void CopyToItem(Node *pn, Item *pi);void InitializeQueue(Queue *pq)&#123; pq-&gt;front = pq-&gt;rear = NULL; pq-&gt;items = 0;&#125;bool QueueIsFull(const Queue *pq)&#123; return pq-&gt;items == MAXQUEUE;&#125;bool QueueIsEmpty(const Queue *pq)&#123; return pq-&gt;items == 0;&#125;int QueueItemCount(const Queue *pq)&#123; return pq-&gt;items;&#125;bool EnQueue(Item item, Queue *pq)&#123; Node *pnew; if (QueueIsFull(pq)) &#123; return false; &#125; pnew = (Node *)malloc(sizeof(Node)); if (pnew == NULL) &#123; fprintf(stderr, "Unable to allocate memory!\n"); exit(1); &#125; CopyToNode(item, pnew); pnew-&gt;next = NULL; if (QueueIsEmpty(pq)) &#123; pq-&gt;front = pnew; &#125;else&#123; pq-&gt;rear-&gt;next = pnew; &#125; pq-&gt;rear = pnew; pq-&gt;items++; return true;&#125;bool DeQueue(Item *pitem, Queue *pq)&#123; Node *pt; if (QueueIsEmpty(pq)) &#123; return false; &#125; CopyToItem(pq-&gt;front, pitem); pt = pq-&gt;front; pq-&gt;front = pq-&gt;front-&gt;next; free(pt); pq-&gt;items--; if (pq-&gt;items == 0) &#123; pq-&gt;rear = NULL; &#125; return true;&#125;void EmptyQueue(Queue *pq)&#123; Item dummy; while (!QueueIsEmpty(pq)) &#123; DeQueue(&amp;dummy, pq); &#125;&#125;static void CopyToNode(Item item, Node *pn)&#123; pn-&gt;item = item;&#125;static void CopyToItem(Node *pn, Item *pi)&#123; *pi = pn-&gt;item;&#125; 二叉搜索树二叉搜索树是一种结合了折半搜索策略的链接结构。树中的每一个节点都包含一个项目和两个指向其他节点的指针。这种构思是每一个节点都有两个子节点，左节点和右节点。在左节点中的项目是父节点中项目的前序项，而在右节点中的项目是父节点中项目的后序项。这种关系存在于每一个有子节点的节点中。 二叉树ADT： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#ifndef tree_h#define tree_h#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct item&#123; char petname[20]; char petkind[20];&#125;Item;#define MAXITEMS 10typedef struct node&#123; Item item; struct node *left; struct node *right;&#125;Node;typedef struct tree&#123; Node *root; int size;&#125;Tree;void InitializeTree(Tree *ptree);bool TreeIsEmpty(const Tree *ptree);bool TreeIsFull(const Tree *ptree);int TreeItemCount(const Tree *ptree);bool AddItem(const Item *pi, Tree *ptree);bool InTree(const Item *pi, const Tree *ptree);bool DeleteItem(const Item *pi, Tree *ptree);void Traverse(const Tree *ptree, void (*pfun)(Item item));void DeleteAll(Tree *ptree);#endif /* tree_h */#include "tree.h"#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct pair&#123; Node *parent; Node *child;&#125;Pair;static Node *MakeNode(const Item *pi);static bool ToLeft(const Item *i1, const Item *i2);static bool ToRight(const Item *i1, const Item *i2);static void AddNode(Node *new_node, Node *root);static void InOrder(const Node *root, void (*pfun)(Item item));static Pair SeekItem(const Item *pi, const Tree *ptree);static void DeleteNode(Node **ptr);static void DeleteAllNodes(Node *ptr);void InitializeTree(Tree *ptree)&#123; ptree-&gt;root = NULL; ptree-&gt;size = 0;&#125;bool TreeIsEmpty(const Tree *ptree)&#123; if (ptree-&gt;root == NULL) &#123; return true; &#125; return false;&#125;bool TreeIsFull(const Tree *ptree)&#123; if (ptree-&gt;size == MAXITEMS) &#123; return true; &#125; return false;&#125;int TreeItemCount(const Tree *ptree)&#123; return ptree-&gt;size;&#125;bool AddItem(const Item *pi, Tree *ptree)&#123; Node *new_node; if (TreeIsFull(ptree)) &#123; fprintf(stderr, "Tree is full\n"); return false; &#125; if (SeekItem(pi, ptree).child != NULL) &#123; fprintf(stderr, "Attemped to add duplicate item\n"); return false; &#125; new_node = MakeNode(pi); if (new_node == NULL) &#123; fprintf(stderr, "Couldn`t create node\n"); return false; &#125; ptree-&gt;size++; if (ptree-&gt;root == NULL) &#123; ptree-&gt;root = new_node; &#125;else&#123; AddNode(new_node, ptree-&gt;root); &#125; return true;&#125;bool InTree(const Item *pi, const Tree *ptree)&#123; return (SeekItem(pi, ptree).child == NULL)?false:true;&#125;bool DeleteItem(const Item *pi, Tree *ptree)&#123; Pair look; look = SeekItem(pi, ptree); if (look.child == NULL) &#123; return false; &#125; if (look.parent == NULL) &#123; DeleteNode(&amp;ptree-&gt;root); &#125;else if (look.parent-&gt;left == look.child)&#123; DeleteNode(&amp;look.parent-&gt;left); &#125;else&#123; DeleteNode(&amp;look.parent-&gt;right); &#125; ptree-&gt;size--; return true;&#125;void Traverse(const Tree *ptree, void (*pfun)(Item item))&#123; if (ptree != NULL) &#123; InOrder(ptree-&gt;root, pfun); &#125;&#125;void DeleteAll(Tree *ptree)&#123; if (ptree != NULL) &#123; DeleteAllNodes(ptree-&gt;root); &#125; ptree-&gt;root = NULL; ptree-&gt;size = 0;&#125;static void InOrder(const Node *root, void (*pfun)(Item item))&#123; if (root != NULL) &#123; InOrder(root-&gt;left, pfun); (*pfun)(root-&gt;item); InOrder(root-&gt;right, pfun); &#125;&#125;static void DeleteAllNodes(Node *root)&#123; Node *pright; if (root != NULL) &#123; pright = root-&gt;right; DeleteAllNodes(root-&gt;left); free(root); DeleteAllNodes(pright); &#125;&#125;static void AddNode(Node *new_node, Node *root)&#123; if (ToLeft(&amp;new_node-&gt;item, &amp;root-&gt;item)) &#123; if (root-&gt;left == NULL) &#123; root-&gt;left = new_node; &#125;else&#123; AddNode(new_node, root-&gt;left); &#125; &#125;else if (ToRight(&amp;new_node-&gt;item, &amp;root-&gt;item))&#123; if (root-&gt;right == NULL) &#123; root-&gt;right = new_node; &#125;else&#123; AddNode(new_node, root-&gt;right); &#125; &#125;else&#123; fprintf(stderr, "location error in AddNode()\n"); exit(1); &#125;&#125;static bool ToLeft(const Item *i1, const Item *i2)&#123; int comp1; if ((comp1 = strcmp(i1-&gt;petname, i2-&gt;petname)) &lt; 0) &#123; return true; &#125;else if (comp1 == 0 &amp;&amp; strcmp(i1-&gt;petkind, i2-&gt;petkind) &lt; 0)&#123; return true; &#125;else&#123; return false; &#125;&#125;static bool ToRight(const Item *i1, const Item *i2)&#123; int comp1; if ((comp1 = strcmp(i1-&gt;petname, i2-&gt;petname)) &gt; 0) &#123; return true; &#125;else if (comp1 == 0 &amp;&amp; strcmp(i1-&gt;petkind, i2-&gt;petkind) &gt; 0)&#123; return true; &#125;else&#123; return false; &#125;&#125;static Node *MakeNode(const Item *pi)&#123; Node *new_node; new_node = (Node *)malloc(sizeof(Node)); if (new_node != NULL) &#123; new_node-&gt;item = *pi; new_node-&gt;left = NULL; new_node-&gt;right = NULL; &#125; return new_node;&#125;static Pair SeekItem(const Item *pi, const Tree *ptree)&#123; Pair look; look.parent = NULL; look.child = ptree-&gt;root; if (look.child == NULL) &#123; return look; &#125; while (look.child != NULL) &#123; if (ToLeft(pi, &amp;(look.child-&gt;item))) &#123; look.parent = look.child; look.child = look.child-&gt;left; &#125;else if (ToRight(pi, &amp;(look.child-&gt;item)))&#123; look.parent = look.child; look.child = look.child-&gt;right; &#125;else&#123; break; &#125; &#125; return look;&#125;static void DeleteNode(Node **ptr)&#123; Node *temp; puts((*ptr) -&gt;item.petname); if ((*ptr)-&gt;left == NULL) &#123; temp = *ptr; *ptr = (*ptr)-&gt;right; free(temp); &#125;else if ((*ptr)-&gt;right == NULL)&#123; temp = *ptr; *ptr = (*ptr)-&gt;left; free(temp); &#125;else&#123; for (temp = (*ptr)-&gt;left; temp-&gt;right != NULL; temp = temp-&gt;right) &#123; continue; &#125; temp-&gt;right = (*ptr)-&gt;right; temp = *ptr; *ptr = (*ptr)-&gt;left; free(temp); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git的基本用法和扩展]]></title>
    <url>%2F2018%2F02%2F02%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Git 简史Git的简单介绍和相关原理Linux内核是一个超大规模的开源软件项目，早期对Linux的维护采用的是通过传递补丁和归档文件的方式来实现的。直到2002年，Linux内核项目开始采用一个叫BitKeeper的专有分布式版本控制系统。 2005年，Linux内核开发者社区与BitKeeper的研发公司关系破裂，该公司收回了软件的免费使用权，促使Linux开发社区(尤其是Linux之父林纳斯·托瓦兹)在吸取BitKeeper的使用经验上，开发出了自己的版本控制系统Git。 新的版本控制系统具有如下特点： 速度快。 设计简洁。 对非线性开发强有力的支持(即git的分支管理功能)。 完全分布式设计。 能够有效的处理像Linux内核这种大型项目。 Git与其他版本控制系统最大的不同在于其对待数据的方式，其他大多数版本控制系统(SVN、CVS等)以文件变化列表的方式存储信息。这类系统将其存储的信息视为一组文件以及对这些文件随时间所做的变更。 而Git并没有采取这种方式对待和存储数据。它更像是将数据视为一个微型文件系统的一组快照。每次提交或在Git中保存项目的状态时，Git基本上会抓取一张所有文件当前状态的快照，然后存储一个之昂想该快照的引用。处于效率考虑，如果文件并没有发生变动，Git则不会再重新保存文件，而是留下一个指向先前已保存过的相同的文件的链接。 还有一点是Git中的大部分操作只需要用到本地文件和资源。一般无需从网络上获取信息。项目完整的历史记录都存在本地磁盘上，所以绝大多数的操作都能瞬间完成。 Git使用的核心内容在Git中，文件可以处于以下三种状态之一：已提交、已修改、已暂存。 已提交：表示数据已经被安全存入本地数据库中。 已修改：表示已经改动了文件，但尚未提交到数据库。 已暂存：表示对已修改的文件的当前版本做出了标识并将其加入下一次要提交的快照中。 文件状态变更的流程如下所示： Git基础获取Git仓库建立Git项目的方式有两种 第一种是在现有项目的目录中初始化Git仓库，操作步骤如下： 进入项目目录并输入 git init，这会创建一个.git的隐藏文件夹（快捷键⌘ + ⇧ + . 可显示隐藏文件），这个文件夹包含了构成Git仓库骨架的所有必须的文件。但此时Git尚未跟踪项目中的任何文件。可以执行命令git add [filename]使Git跟踪指定的文件，也可以输入git add .跟踪当前目录下的所有文件，然后再输入git commit命令即可： 123$ git add *.c$ git add LICENSE$ git commit -m 'init version' 第二种是克隆现有仓库 如果需要获取一份现有仓库的副本，可以使用git clone命令，该命令默认会从服务器上把整个项目历史中每个文件的所有历史版本都拉取下来，克隆仓库需要使用git clone [url]命令，例如： $ git clone https://github.com/libgit2/libgit2 执行此命令后会在终端当前的目录创建一个名为libgit2的新目录，并在其中初始化.git目录，然后将远程仓库中所有数据拉取到本地并检出最新版本的可用副本。如果想将项目克隆到其他名字的目录中，可以把目录名作为命令行选项传入： $ git clone https://github.com/libgit2/libgit2 mylibgit 在Git仓库中记录变更请记住，工作目录下的每个文件都处于两种状态之一：已跟踪（tracked）或未跟踪（untracked）。已跟踪的文件又可分为未修改、已修改和已暂存三种状态。如果修改了文件，他们在Git中的状态会变成已修改，这意味着自上次提交以来文件已经发生了变化。接下来要把这些已修改的文件添加到暂存区，提交所有已暂存的变更，随后重复这个过程。 检测文件所处状态主要命令是git status，虽然git status命令的输出信息很全面，但也着实冗长。对此，Git提供了一个现实简短状态的命令行选项git status -s 例如： 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simlegit.rb?? LICENSE.txt 未被跟踪的文件旁边会有一个??标记，已暂存的新文件会有A标记，而已修改的文件会有M标记，已修改并被添加到暂存区，之后又被修改过会有MM标记。 有时候你并不希望某一类文件被Git自动添加，甚至不希望这些文件被显示在未跟踪的列表中。这种情况下，可以创建名为.gitignore的文件，在其中列出待匹配文件的模式，下面是一个.gitignore文件的例子： 123$ cat .gitignore* .[oa]*~ 其中第一行告诉Git忽略所有以.o或.a结尾的文件，第二行告诉Git忽略所有以~结尾的文件。你也可以让Git忽略log目录、tmp目录、pid目录以及自动生成的文档等。最好在开始工作前配置好.gitignore文件。Github维护了一份相当全面的.gitignore参考示例列表。如果想用它作为自己项目的参考，请访问https://github.com/github/gitignore。 如果git status命令的输出信息对你来说太过泛泛，你想知道具体的内容，而不仅仅是你更改了哪些文件，这是你可以使用git diff命令，该命令会显示你具体添加和删除了哪些行。换句话说，git diff的输出是补丁。如果你想看看有哪些已暂存的内容会进入下一次提交，可以使用git diff —staged命令。 所有未暂存的变更都不会进入到提交的内容中，而所有已暂存的变更在执行git commit命令后都会进入到本地仓库。完成上述提交还有另外一种方式，那就是直接在命令行上键入提交信息。如：git commit -m &#39;first commit&#39;，请记住，提交时记录的是暂存区中的快照，任何未暂存的内容任然保持着已修改状态。 如果你想要跳过暂存区直接提交，Git为你提供了更快捷的途径。给git commit命令传入-a选项，就能让Git自动把已跟踪的所有文件添加到暂存区，然后再提交，这样你就不用再执行git add命令了。例如：git commit -am &#39;first commit&#39; 查看提交历史在完成了几次提交，或者克隆了一个已有提交历史的仓库后，你可能想要看看历史记录。可以使用git log命令来实现，这是最基础却又最强大的一条命令。下面是截取的MBProgressHUD的log一部分如下： 123456789101112$ git logcommit c954ef3806f135a4d6bb4e18e9b4b64dfd52995a (HEAD -&gt; master, origin/master, origin/HEAD)Merge: a90765f c63cf18Author: Matej Bukovinski &lt;matej@bukovinski.com&gt;Date: Thu Nov 30 21:19:46 2017 +0100Merge pull request #513 from niveus/Remove-NSLogRemove NSLogcommit c63cf1840e70f2980e9fae992866945389fa07f1Author: jason &lt;jason.gabriele@dexcom.com&gt;Date: Thu Nov 30 09:52:15 2017 -0800Remove NSLog 默认不加参数的情况下，git log会按照时间顺序列出仓库中所有提交，其中最新的提交显示在最前面。每一个提交都会列出它的SHA-1校验和、作者的姓名和邮箱、提交日期以及提交信息。 git log有很多不同的选项，可以直观的展示出所需的内容。现在我们来看一些常见的选项。-p，它会显示出每次提交所引入的差异。你还可以加上-2参数，只输出最近两次提交。--stat选项会在每个提交下面列出如下内容：改动的文件列表、共有多少文件被改动以及文件里有多少新增行和删除行。另外还会在最后输出总计信息。--pretty它可以更改日志输出的默认格式。Git有一些预置的格式供你选择。例如oneline它可以在每一行中显示一个提交。short、full、fuller格式选项会分别比默认输出减少或增加一些信息： 123456$ git log --pretty=onelinec954ef3806f135a4d6bb4e18e9b4b64dfd52995a (HEAD -&gt; master, origin/master, origin/HEAD) Merge pull request #513 from niveus/Remove-NSLogc63cf1840e70f2980e9fae992866945389fa07f1 Remove NSLoga90765f5f2a825507490355dc9d253e2c202c7ee Merge pull request #90 from matej/matej/hide-timer-race549fa2854636d00225819a7b120c505b324b5dd9 Add a test case for the hide delayed race1f1d7ce8bdb6a82d9275163323d503c221cdfe65 Use the new method signature in comments 最值得注意的选项是format，它允许你指定自己的输出格式。下面是截取的MBProgressHUD的log一部分： 1234567$ git log --pretty=format:"%h - %an, %ar : %s"c954ef3 - Matej Bukovinski, 3 months ago : Merge pull request #513 from niveus/Remove-NSLogc63cf18 - jason, 3 months ago : Remove NSLoga90765f - Matej Bukovinski, 3 months ago : Merge pull request #90 from matej/matej/hide-timer-race549fa28 - Matej Bukovinski, 3 months ago : Add a test case for the hide delayed race1f1d7ce - Matej Bukovinski, 3 months ago : Use the new method signature in comments16e8622 - Matej Bukovinski, 3 months ago : Prevent a race when invalidating the hide 格式选项 输出的格式描述 %H 提交对象的散列值(校验和) %h 提交对象的简短散列值 %T 树对象的散列值 %t 树对象的简短散列值 %P 父对象的散列值 %p 父对象的简短散列值 %an 作者的名字 %ae 作者的电子邮箱地址 %ad 创作日期 %ar 相对于当前日期的创作日期 %cn 提交者的名字 %ce 提交者的电子邮箱地址 %cd 提交日期 %cr 相对于当前日期的提交日期 %s 提交信息的主题 oneline和format这两个选项如果与log命令的另一个选项--graph一起使用，就能发挥更大的作用。具体来说--graph选项会用ASCII字符形式的的简单图表来显示Git分支和合并历史，如下所示： 12345678910111213141516171819* d55891f Merge branch 'master' of git://github.com/jdg/MBProgressHUD|\| * 886d26f hudWasHidden delegate method should be required| * 6d55851 Remove changelog.txt; update README.| * df6df4c Merge branch 'master' of git://github.com/zenwheel/MBProgressHUD| |\| | * 8985308 fix for leak when changing indicator style| | * 5ba1a24 added setNeedsDisplay to get label changes to appear| * | bcccd47 Sleep before showing.| * | ce752d9 Added delayed display.| |/| * fee25a5 Adding offsets and delays. Offsets work, but don't protect against over/underflow; delays don't work yet.| * 26ab9ca Updating gitignore.| * 4f5b96f Reformatting the code to look like I like it.| * 4c9eba6 Adapting the HUD Demo to the slightly changed directory structure.| * 059cf87 Importing 0.31 from zip download* | 5423124 Updated labelText and detailsLabelText properties.|/* 201c6cd Add hide/show functions. 撤销操作(版本回退)有一种撤销操作的常见使用场景是提交之后才发现自己忘了添加某些文件，或者写错了提交信息。如果这时你想要重新尝试提交，可以使用--amend选项： 123$ git commit -m 'initial commit'$ git add forgottn_file$ git commit --amend 上面的例子最终会产生一个提交，因为第二个提交命令修正了第一个提交的结果。 假如你不小心将一个无关文件添加到了暂存区，你想要将该文件移出暂存区，可以使用git reset HEAD &lt;file&gt;…命令把文件移出暂存区。 如果你突然发现，自己不再需要对CONTRIBUTING.md文件所做的更改，可以使用git checkout -- &lt;file&gt;.. 如果我们需要回退到某一版本并且放弃所有的修改，可以使用git reset --hard 校验码，把当前的版本回退到上X个版本可以使用git reset --hard HEAD~x。如果我们想会退到之后的版本，可以先执行git reflog找到你要回退的那个版本的校验码，然后使用git rest --hard 校验码就可以成功的会退到当前版本之后的版本了(前提是你是有之后的版本的)。 回退远程仓库的版本先在本地切换到远程仓库要回退的分支对应的本地分支，然后本地回退至你需要的版本，然后执行：git push &lt;仓库名&gt; &lt;分支名&gt; -f 如何以当前版本为基础，回退指定个commit 首先，确认你当前的版本需要回退多少个版本，然后计算出你要回退的版本数量，执行如下命令：git reset HEAD~X //X代表你要回退的版本数量，是数字！！！！ 需要注意的是，如果你是合并过分支，那么背合并分支带过来的commit并不会被计入回退数量中，而是只计算一个，所以如果需要一次回退多个commit，不建议使用这种方法 如何回退到和远程版本一样 有时候，当发生错误修改需要放弃全部修改时，可以以远程分支作为回退点退回到与远程分支一样的地方，执行的命令如下 1git reset --hard origin/master // origin代表你远程仓库的名字，master代表分支名 远程仓库的使用 远程仓库是指在互联网或其他网络上托管的项目版本仓库。你可以拥有一个或多个远程仓库，而对于其中每个仓库，你可能拥有只读权限或读写权限。要同别人协作就需要管理这些远程仓库，在需要分享工作成果时，向其推送数据，从中拉取数据。管理远程仓库需要知道如何添加远程仓库、移除无效的远程仓库、管理各种远程仓库的分支和设置是否跟踪这些分支。 要查看已经设置了哪些远程仓库，请使用git remote命令。该命令会列出每个远程仓库的简短名称。在克隆某个仓库之后，你至少可以看到名为origin的远程仓库，这是Git给克隆源服务器取的默认名称。你也可以使用-v参数，这样会显示出Git存储的每个远程仓库对应的URL： 12345➜ MBProgressHUD git:(master) git remoteorigin➜ MBProgressHUD git:(master) git remote -vorigin https://github.com/jdg/MBProgressHUD.git (fetch)origin https://github.com/jdg/MBProgressHUD.git (push) 要添加一个远程仓库，并给它起个简短的名称以便引用，可以执行git remote add [shortname] &lt;url&gt; 要从远程仓库获取数据，可以执行git fetch [remote-name]命令。 当你的项目进行到某个阶段，需要与他人分享你的工作成果时，就要把变更推送到远程仓库中去。可以使用git push [remote-name] &lt;branch-name&gt;，如果想把本地的master分支推送到远程的origin服务器上，那么可以执行以下命令，把任意提交推送到服务器端： 1$ git push origin master 上述命令能够正常工作的前提是必须拥有克隆下来的远程仓库的写权限，并且克隆后没有任何其他人向远程仓库中推送数据。如果别人和你都克隆了这个仓库，而他先推送，你后推送，那么你的这次推送会直接被拒绝。你必须先拉取别人的变更，将其整合到你的工作成果中，然后才能推送。 可以用git remote rename来重命名远程仓库。如果想要把pb重命名为paul，可以用git remote rename命令来实现，如下所示： 1$ git remote rename pb paul 有时出于某种原因，需要删除某个远程仓库地址，可以使用git remote rm命令，如下所示： 1$ git remote rm paul 标签就像大多数版本控制系统一样，Git可以把特定的历史版本标记为重要版本。其典型的应用场景就是标出发布版本（v1.0等）。本节你可学习到如何列举所有可用的标签，如何创建新的标签以及不同标签之间的差异。 在Git中，列举可用标签的操作很简单，只需键入git tag即可： 123$ git tagv0.1v1.3 Git使用的标记主要有两种类型：轻量标签和注释标签。 轻量标签像是一个不变的分支——他只是一个指向某次提交的指针。 注释标签会作为完整对象存储在Git数据库中。Git会计算其校验和，还包含如标记者的名字、邮箱地址和标签的创建时间，还有标记消息，一般推荐使用注释标签。 注释标签的创建只需执行带有-a选项的tag命令即可： $ git tag -a v1.4 -m &quot;my version 1.4&quot; 轻量标签基本上就是把提交的校验和保存到文件中，除此不包含任何信息： $ git tag v1.4 你还可以随后再给之前的提交添加标签。如下 123456$ git log --pretty=onelinec954ef3806f135a4d6bb4e18e9b4b64dfd52995a (HEAD -&gt; master, origin/master, origin/HEAD) Merge pull request #513 from niveus/Remove-NSLogc63cf1840e70f2980e9fae992866945389fa07f1 Remove NSLoga90765f5f2a825507490355dc9d253e2c202c7ee Merge pull request #90 from matej/matej/hide-timer-race549fa2854636d00225819a7b120c505b324b5dd9 Add a test case for the hide delayed race1f1d7ce8bdb6a82d9275163323d503c221cdfe65 Use the new method signature in comments 假如你忘记在Remove NSLog这次提交上添加v1.2的标签，只需在命令最后指定提交的校验和(或部分校验和)，执行git tag -a v1.2 c63cf18 默认情况下，git push命令不会把标签传输到远程服务器上。在创建标签之后，你必须明确地将标签推送到服务器上。这个过程有点像推送分支，对应的命令是git push origin [tagname] $ git push origin v1.5 如果你有很多标签需要一次性推送，可以使用git push命令的--tags选项。 $ git push origin --tags Git别名如果你键入的Git命令不完整，Git不会自动推断命令并补全命令。虽然如此，如果你想每次都费力的键入完整的Git命令，也可以轻松通过git config设置每个Git命令的别名。下面是一些你想设置的别名：$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status Git分支机制 有些人把Git的分支模型称为Git的杀手锏特性，而这项特性也确实使得Git从众多版本控制系统中脱颖而出。实际上，Git分支功能轻量到了极致，以至于有关分支的操作几乎是及时完成的，并且在不同分支之间切换基本上也同样迅速。 分支机制简述 Git的分支只不过是一个指向某次提交的轻量级的可移动的指针。Git默认的分支名称是master。当你发起提交时，就有了一个指向最后一次提交的master分支。每次提交时，它都会自动向前移动。 基本的分支与合并操作Git默认的分支名是master。当你想要创建一个新的分支可以使用git branch [branch_name]，这会创建一个指向当前提交的新指针。Git是如何确定你当前处在哪个分支上的呢？实际上Git维护着一个名为HEAD的特殊指针。在Git中，HEAD是一个指向当前所在的本地分支的指针。 要切换到已有的分支，可以执行git checkout命令，例如: 1$ git checkout testing 这条命令会改变HEAD指针，使其指向testing分支。而有一个简单方式可以在创建分支的同时又将HEAD指针切换到该分支上，使用命令git checkout -b。 如果你想将分支hotfix合并到master主分支上，可以使用git merge命令来完成操作： 具体操作流程如下： 12$ git checkout master$ git merge hotfix 合并时你会注意到出现了fast-forward的提示，由于当前所在的master分支指向的提交是要并入的hotfix分支的直接上游，因而Git会将master分支指针向前移动。因为这种单线历史不存在有分歧的工作。这就叫fast-forward 合并完成后我们就可以删除hotfix分支，并继续完成iss53的工作123$ git brancn -d hotfix$ git checkout iss53$ git commit -am &apos;commit&apos; 假设现在iss53上面的工作已经完成，可以合并到master分支了。这次合并操作实现与上面的相同。但操作的结果却不一样了，在这次合并中，开发历史从某个早先的时间点开始有了分叉。由于当前的master分支指向的提交不是iss53分支的直接祖先，因而Git必须要做一些额外的工作。本例中，Git执行的操作是简单的三方合并。三方合并操作会使用两个待合并分支上最新提交的快照，以及这两个分支的共同祖先的提交快照。 与之前的做法不同，这一次Git会基于三方合并的结果创建新的快照，让后再创建一个提交指向新建的快照。这个提交叫做‘’合并提交’‘。合并提交的特殊性在于他拥有不止一个父提交。 与分支有关的工作流长期分支 很多使用Git的开发者都喜欢用这种方式创建他们自己的工作流。例如，其中一种流程就是在master分支上只存放稳定版的代码。他们会使用另一种叫作develop或next的平行分支用于开发，或是测试代码的稳定性。这个分支不会一直保持稳定版本，不过一旦他达到了稳定版本的状态，就可以把它合并到master分支去。这样的分支也被用来接收主题分支(例如前面的iss53分支)的合并，来确保这些新开发的特性能够通过所有测试而不会引发新的错误。 如下是一个典型的工作流模式： 远程分支远程分支是指向远程仓库的分支的指针，这些指针存在于本地且无法移动。当你与服务器进行任何网络通信时，它们会自动更新。远程分支有点像书签，它们会提示你上一次连接服务器时远程仓库中每个分支的位置。 假设我们现在有个github.ourcompany.com的服务器，服务器上已存在正在进行的项目： 如果你将内容从服务器上克隆到本地，Git的clone命令会自动把这台服务器命名为origin，并拉取它的全部数据，然后会在本地创建指向服务器上master分支的指针，并命名为origin/master。Git接着会帮你创建你自己的本地master分支。如下所示： 假设你在本地的master分支上进行了一些工作，于此同时，别人向github.outcompany.com推送了数据，更新了服务器上的master分支，这时你的历史提交就与服务器的历史产生了偏差。而且，只要你不与服务器通信，你的origin/master指针就不会移动。 要与服务器同步，需要执行git fetch origin命令。这条命令会查询origin对应的服务器地址，并从服务器取得所有本地尚未包含的数据，然后更新本地数据库，最后把origin/master指针移动到最新位置上去 当需要同别人共享某个分支上的工作成果时，就要把它推送到一个具有写权限的远程仓库。假设你有一个叫做serverfix的分支需要与其他人协作开发，你可以按照之前推送第一个分支的方式推送它。只需执行git push （remote_name） （branch_name）命令即可 1$ git push origin serverfix 当你和你的同事已经完成了一个功能，并且把工作合并到了远程的主分支master上，你已经不再需要这个功能的远程分支了。可以通过git push --delete选项来删除远程分支。例如： 1$ git push origin —delete serverfix 变基在Git中，要把更改从一个分支整合到另一个分支，有两种主要的方式：合并(merge)和变基(rebase)。 比如上面这种情况，我们之前采用的是merge命令，我们依然记得该命令会对两个分支上的最新提交快照以及这两个提交快照最近的共同祖先，进行一次三方合并，并创建一个新的合并提交。 实际上除了上述方式之外还有一种方式：你可以把C5提交的更改以补丁的形式应用到C4上。在Git中，这就叫变基操作。该操作使用的是rebase命令，会把某个分支上的所有提交的更改在另一个分支上重现一遍。这样我们可以对上面的这种情况进行如下操作： 12$ git checkout iss53$ git rebase master 现在你可以回到master分支进行快进合并(fast-forward merge): 12$ git checkout master$ git merge iss53 到此为止，通过rebase和merge的方法得到的最终快照是完全一样的，但使用变基的方式可以获得更简洁的提交历史。 变基操作可以带来种种好处。但它并非完美无缺，其缺点可以总结成一句话：不要对已经存在于本地仓库之外的提交执行变基操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[从AFN到YTKN探究]]></title>
    <url>%2F2017%2F05%2F02%2FAFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[从AFN到YTKN探究AFNetworking框架组成AFNetworking核心代码调用顺序 第一步:使用AFNetworking进行网络请求1234567AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];[manager GET:@&quot;http://localhost&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;&#125;]; 第二步：AFHTTPSessionManager的所有可选的初始化方法都最终调用到下面这个方法1234567891011121314151617181920- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration&#123; self = [super initWithSessionConfiguration:configuration]; if (!self) &#123; return nil; &#125; // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123; url = [url URLByAppendingPathComponent:@&quot;&quot;]; &#125; self.baseURL = url; self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self;&#125; 第三步：初始化完成之后开始调用请求网络的方法(所有的请求方法最终都调用到了下面这个方法) 1234567891011121314151617181920212223242526272829303132333435363738- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure&#123; NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; if (serializationError) &#123; if (failure) &#123; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123; failure(nil, serializationError); &#125;); &#125; return nil; &#125; __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123; if (error) &#123; if (failure) &#123; failure(dataTask, error); &#125; &#125; else &#123; if (success) &#123; success(dataTask, responseObject); &#125; &#125; &#125;]; return dataTask;&#125; *续第三步1. request 的生成方法（是由 AFURLRequestSerialization 类来执行的）12345678910111213141516171819202122232425- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(URLString); NSURL *url = [NSURL URLWithString:URLString]; NSParameterAssert(url); NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url]; mutableRequest.HTTPMethod = method; for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123; [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath]; &#125; &#125; mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy]; return mutableRequest;&#125; 续第三步2 进一步对 request 进行参数的整合编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; NSString *query = nil; if (parameters) &#123; if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; if (query &amp;&amp; query.length &gt; 0) &#123; mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @&quot;&quot;; &#125; if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123; [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; &#125; [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125; 第四步 经过第三步我们最终得到了一个 request ，现在以这个 request 来生成一个 Task1234567891011121314- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; dataTask = [self.session dataTaskWithRequest:request]; &#125;); [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125; 续第四步1 生成了 Task 后，我们利用自定义的代理来监听请求的状态和进度 123456789101112131415 - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; delegate.manager = self; delegate.completionHandler = completionHandler; dataTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:dataTask]; delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;]]></content>
  </entry>
</search>
