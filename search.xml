<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git的基本用法和扩展]]></title>
    <url>%2F2018%2F02%2F02%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Git 简史Git的简单介绍和相关原理Linux内核是一个超大规模的开源软件项目，早期对Linux的维护采用的是通过传递补丁和归档文件的方式来实现的。直到2002年，Linux内核项目开始采用一个叫BitKeeper的专有分布式版本控制系统。 2005年，Linux内核开发者社区与BitKeeper的研发公司关系破裂，该公司收回了软件的免费使用权，促使Linux开发社区(尤其是Linux之父林纳斯·托瓦兹)在吸取BitKeeper的使用经验上，开发出了自己的版本控制系统Git。新的版本控制系统具有如下特点：1.速度快。2.设计简洁。3.对非线性开发强有力的支持。4.完全分布式设计。5.能够有效的处理像Linux内核这种大型项目。 Git与其他版本控制系统最大的不同在于其对待数据的方式，其他大多数版本控制系统(SVN、CVS等)以文件变化列表的方式存储信息。这类系统将其存储的信息视为一组文件以及对这些文件随时间所做的变更。而Git并没有采取这种方式对待和存储数据。它更像是将数据视为一个微型文件系统的一组快照。每次提交或在Git中保存项目的状态时，Git基本上会抓取一张所有文件当前状态的快照，然后存储一个之昂想该快照的引用。处于效率考虑，如果文件并没有发生变动，Git则不会再重新保存文件，而是留下一个指向先前已保存过的相同的文件的链接。还有一点是Git中的大部分操作只需要用到本地文件和资源。一般无需从网络上获取信息。项目完整的历史记录都存在本地磁盘上，所以绝大多数的操作都能瞬间完成。 Git使用的核心内容在Git中，文件可以处于以下三种状态之一：已提交、已修改、已暂存。已提交：表示数据已经被安全存入本地数据库中。已修改：表示已经改动了文件，但尚未提交到数据库。已暂存：表示对已修改的文件的当前版本做出了标识并将其加入下一次要提交的快照中。 1.1 获取Git仓库 $ git init 初始化仓库$ git add 跟踪指定文件$ git add . 跟踪目录下的所有文件$ git clone [url] 克隆现有仓库 1.2 在Git仓库中记录变更 $ git status 查看当前文件状态$ git status -s查看更精简的文件状态$ echo &#39;My Project&#39; &gt; README 创建文本$ vim [filename] 打开指定文件并编辑$ git diff 查看尚未添加到暂存区的变更(详细内容)$ git diff --staged 已暂存等待提交的内容$ git commit -m “message&quot; 提交变更并附带说明$ git commit -am &quot;message&quot;跳过暂存区，直接提交并附带说明$ git rm [filename] 移除文件取消对该文件的跟踪$ git mv [file_from] [file_to]重命名文件 1.3 查看提交历史 $ git log最基本的查看提交历史$ git log -p -2查看最近两次提交的历史并显示每次提交所引入的差异$ git log --stat改动文件的修改数的提交历史$ git log --pretty=onelineprettty是修改日志输出的默认格式，oneline是精简单行显示$ git log --oneline --decorate --graph --all图形化显示分支结构12345678910111213141516TangdeMacBook-Pro:GitTestFile retouch$ git log --oneline --decorate --graph --all* 36d7e26 (HEAD -&gt; master) 修改了readme.txt中的内容* af6d8d9 the fourth modified readme.txt| * 139f200 (action) 修改了readme2.txt中的内容| * 5659990 Create action branch and add readme2.txt| | * db01378 (test) 第二次修改readme2.txt| |/| * 8fd49df 第一次修改了readme1.txt文件中的内容| * 33cbb80 创建了test分支并在此分支中新增了readme.txt文件|/* a510523 (tag: V1.0.3) the third modified readme.txt* 0082357 (tag: V1.0.2) the second modified th readme.txt* 75be658 (tag: V1.0.1) the first modified the readme.txt* 329f6bd Initialized git and add readme.txt file* 41c27e9 (tag: V1.0.0) Create readme.txt fileTangdeMacBook-Pro:GitTestFile retouch$ 1.4 撤销操作 $ git commit --amend更改最近一次提交信息$ git reset HEAD [filename]将指定暂存区的文件移出$ git checkout -- [filename]撤销对文件的修改$ git reset --hard HEAD^或者$ git reset --hard HEAD~1回退到上一个版本$ git reset --hard [commit_id]会退到指定的版本$ git reflog查看命令历史 1.5 远程仓库的使用 $ git remote [shortname] [url]添加一个远程仓库，并给他一个简短的名称以便引用$ git fetch [remote-name]从远程项目获取更新数据$ git clone [url]克隆远程仓库的版本到本地，成功后本地就有了和远程仓库相同的代码。并且已经和远程仓库连接成功.$ git push [remote-name] [branch-name]将本地指定的分支数据推送到指定的远程服务器上$ git remote show [remote-name]查看某一远程仓库的更多信息$ git remote rename [oldname] [newname]重命名远程仓库$ git remote rm [remote-name] 删除指定的远程仓库 1.6 标记标签 $ git tag列举所有标签$ git tag -a V1.0.0 -m &quot;message&quot;创建标签并附带说明$ git show V1.0.0查看某一个标签的详细信息和对应的提交信息$ git tag -a V1.2.2 9fceb02给某一个提交版本补加标签$ git push [remote-name] [tagname]默认情况git push命令不会把标签传输到远程服务器上，你必须明确将某个标签信息共享到服务器上 1.7 Git 别名 $ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status$ git config --global alias.last &#39;log -1 HEAD&#39;查看最近一次提交信息的别名设置 2.0 Git分支 $ git branch列举当前项目下的所有分支，带*号的分支表示当前处于的分支$ git branch [branch-name]创建一个新的分支$ git checkout [branch-name]切换到指定的分支上$ git checkout -b [branch-name]创建并切换到该分支上$ git merge [branch-name]合并指定分支到当前分支$ git branch -d [branch-name]删除某一分支$ git branch --merged显示已并入当前分支的所有分支$ git branch --no-merged显示尚未并入的所有分支$ git push [remote-name] --delete [branch-name]删除远程分支 Git服务器1.1 Git的各种协议和优劣性比较git使用4种主要的协议来传输数据：本地协议，HTTP协议，SSH协议和Git协议。 GitFlow]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
